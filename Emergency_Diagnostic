
---------------------------------------
--Emergency fault find SQL instance
--Run in Text format for easier reading
--Adrian Sleigh
--V5.0 Last updated 24/11/25
--Added QueryStore report
---------------------------------------
SET NOCOUNT ON;
PRINT N'=== üìä SQL Server Emergency Diagnostic Script ===';

--1. Instance Info
SELECT
    'INSTANCE NAME ' + 
    @@SERVERNAME + 
    ' | Last SQL Restart: ' + 
    CONVERT(VARCHAR, sqlserver_start_time, 120) + 
    ' | UPTIME: ' + 
    CAST(DATEDIFF(SECOND, sqlserver_start_time, GETDATE()) / 86400 AS VARCHAR) + ' days, ' +
    CAST((DATEDIFF(SECOND, sqlserver_start_time, GETDATE()) % 86400) / 3600 AS VARCHAR) + ' hours, ' +
    CAST((DATEDIFF(SECOND, sqlserver_start_time, GETDATE()) % 3600) / 60 AS VARCHAR) + ' minutes'
FROM sys.dm_os_sys_info;
------------------------------------------------
--2. DMV-based simplified sp_who2 with ProgramName, Blocking Info, excluding system and SA
PRINT '[--- Current Connections ---]';
PRINT '-----------------------------'

SELECT 
    s.session_id AS [SPID],
    s.status,
   SUBSTRING(s.login_name,1,30) AS [Login],
   SUBSTRING(s.host_name,1,30) AS [HostName],
   SUBSTRING(DB_NAME(r.database_id),1,30) AS [DBName],
    r.command AS [Command],
    r.cpu_time AS [CPUTime],
    r.reads + r.writes AS [DiskIO],
    s.last_request_end_time AS [LastBatch],
   SUBSTRING(s.program_name,1,70) AS [ProgramName],
    r.blocking_session_id AS [BlockedBy],
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM sys.dm_exec_requests WHERE blocking_session_id = s.session_id
        ) THEN 'Yes' ELSE 'No'
    END AS [IsBlockingOthers]
FROM sys.dm_exec_sessions AS s
LEFT JOIN sys.dm_exec_requests AS r ON s.session_id = r.session_id
WHERE s.session_id <> @@SPID
  AND s.is_user_process = 1              -- Exclude system sessions
  AND s.login_name <> 'NT AUTHORITY\SYSTEM'
  AND s.login_name <> 'sa'               -- SA
  AND s.login_name <> 'moxireader'       -- Excludes
ORDER BY r.cpu_time DESC;
----------------------------------------------------------------
--3. Page Life Expectancy
SET NOCOUNT ON
DECLARE @PLE INT;

SELECT @PLE = cntr_value
FROM sys.dm_os_performance_counters
WHERE object_name LIKE '%Buffer Manager%'
  AND counter_name = 'Page life expectancy';

PRINT '[--- Page Life Expectancy ---]';
PRINT '-----------------------------'

SELECT
    @PLE AS PageLifeExpectancy,
    cntr_value AS PageLifeValue,
    RIGHT('0' + CAST(cntr_value / 3600 AS VARCHAR(10)), 2) + ':' +
    RIGHT('0' + CAST((cntr_value % 3600) / 60 AS VARCHAR(10)), 2) + ':' +
    RIGHT('0' + CAST(cntr_value % 60 AS VARCHAR(10)), 2) AS TimeHMS
FROM sys.dm_os_performance_counters
WHERE object_name LIKE '%Buffer Manager%'
  AND counter_name = 'Page life expectancy';

IF @PLE < 500

BEGIN
    PRINT N'‚ö†Ô∏è Warning: Page Life Expectancy is below 500.';
    PRINT 'Investigate memory pressure, buffer pool churn, or large query workloads. Consider reviewing memory settings and query patterns.';
END
ELSE
BEGIN
    PRINT N'‚úÖ Page Life Expectancy is within acceptable range.';
END
------------------------------------------------------------------

--4. CPU Pressure
PRINT '   '
PRINT '[--- CPU Pressure ---]';
PRINT '----------------------'

SELECT 
    total_physical_memory_kb / 1024 AS TotalMemoryMB,
    available_physical_memory_kb / 1024 AS AvailableMemoryMB,
    SUBSTRING(system_memory_state_desc,1,40)AS System_Memory_Desc
FROM sys.dm_os_sys_memory;
------------------------------------------------------------------

--5. Blocking Sessions
PRINT '[--- Blocking Sessions ---]';
PRINT '--------------------------'

IF EXISTS (SELECT 1 FROM sys.dm_exec_requests WHERE blocking_session_id <> 0)
BEGIN 
    PRINT '   '
    PRINT N'‚ö†Ô∏è Issue: Blocking detected.';
    PRINT 'Identify root blocker. If safe, kill session or tune query/index.';

    SELECT 
        r.session_id,
        r.blocking_session_id,
        r.wait_type,
        r.wait_time,
        t.text AS sql_text
    FROM sys.dm_exec_requests r
    CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
    WHERE r.blocking_session_id <> 0;
END
ELSE
BEGIN
    PRINT '   '
    PRINT N'‚úÖNo blocking sessions detected.';
END
------------------------------------------------------------------------
--6. Transaction Log Usage
SET NOCOUNT ON;

DECLARE @Threshold INT = 80;  -- change this to your preferred warning threshold (percent)

IF OBJECT_ID('tempdb..#LogSpace') IS NOT NULL DROP TABLE #LogSpace;
CREATE TABLE #LogSpace (
    DatabaseName sysname,
    LogSizeMB    DECIMAL(18,2),
    LogUsedPct   DECIMAL(18,2),
    Status       INT
);

-- Capture log usage for all databases
INSERT INTO #LogSpace (DatabaseName, LogSizeMB, LogUsedPct, Status)
EXEC ('DBCC SQLPERF(LOGSPACE)');

-- Optional: Exclude offline or restoring DBs
;WITH DbStates AS (
    SELECT d.name, d.state
    FROM sys.databases AS d
)
DELETE ls
FROM #LogSpace AS ls
JOIN DbStates AS ds ON ds.name = ls.DatabaseName
WHERE ds.state <> 0;  -- keep only ONLINE databases
PRINT '   '
PRINT '[---Transaction Log Usage Summary---]';
PRINT '------------------------------------'

-- Fixed-width header
DECLARE @Header1 NVARCHAR(200) = 'DbName                 LogSizeMB   Used%   Status';
DECLARE @Sep    NVARCHAR(200) = REPLICATE('-',22) + ' ' + REPLICATE('-',9) + ' ' + REPLICATE('-',6) + ' ' + REPLICATE('-',6);
PRINT @Header1;
PRINT @Sep;

-- Summary rows
SELECT
    CONCAT(
        LEFT(DatabaseName + SPACE(22), 22), ' ',
        RIGHT(SPACE(9) + CAST(LogSizeMB AS VARCHAR(9)), 9), ' ',
        RIGHT(SPACE(6) + CAST(LogUsedPct AS VARCHAR(6)), 6), ' ',
        RIGHT(SPACE(6) + CAST(Status AS VARCHAR(6)), 6)
    ) AS [Log Usage]
FROM #LogSpace
ORDER BY LogUsedPct DESC, DatabaseName;

-- Warnings for high usage
DECLARE @WarnCount INT = 0;

SELECT @WarnCount = COUNT(*)
FROM #LogSpace
WHERE LogUsedPct >= @Threshold;

IF @WarnCount > 0
BEGIN
    PRINT N'‚ö†Ô∏è--- WARNINGS ---';
    SELECT 
        CONCAT(
            'WARNING: ', DatabaseName, ' log usage is ',
            CAST(LogUsedPct AS VARCHAR(10)), '% (size ',
            CAST(LogSizeMB AS VARCHAR(20)), ' MB). Consider log backup/checkpoint/investigate long-running transactions.'
        ) AS [Warning]
    FROM #LogSpace
    WHERE LogUsedPct >= @Threshold
    ORDER BY LogUsedPct DESC;
END
ELSE
BEGIN
    PRINT N'‚úÖAll databases are below the transaction log usage threshold.';
END
-------------------------------------------------------------
--7. Long-running Queries
PRINT '   '
PRINT '[--- Long-running Queries (>5 min) ---]';
PRINT '--------------------------------------'

IF EXISTS (
    SELECT 1
    FROM sys.dm_exec_requests r
    CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
    WHERE r.total_elapsed_time > 300000
      AND t.text NOT LIKE '%sp_server_diagnostics%'
)
BEGIN
    PRINT '   '
    PRINT '‚ö†Ô∏è Long-running request detected (excluding sp_server_diagnostics).';

    SELECT 
        N'‚ö†Ô∏è' AS LongRunningQuery,
        r.session_id,
        r.total_elapsed_time / 1000 AS ElapsedSec,
        SUBSTRING(t.text, 1, 100) AS sql_text
    FROM sys.dm_exec_requests r
    CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
    WHERE r.total_elapsed_time > 300000
      AND t.text NOT LIKE '%sp_server_diagnostics%';
END
ELSE
BEGIN
    PRINT '   '
    PRINT N'‚úÖNo long-running queries over 5 minutes.';
END
--------------------------------------------------------------
--8.  Availability Group Health
PRINT '   '
PRINT '[--- Availability Group Health ---]';
PRINT '-----------------------------------'

IF EXISTS (
    SELECT 1 FROM sys.dm_hadr_availability_replica_states WHERE role_desc = 'PRIMARY'
)
BEGIN
    IF EXISTS (
        SELECT 1
        FROM sys.dm_hadr_database_replica_states
        WHERE synchronization_state_desc <> 'SYNCHRONIZED'
           OR log_send_queue_size > 10000
           OR redo_queue_size > 10000
    )
    BEGIN 
	    PRINT '   '
        PRINT N'‚ö†Ô∏è Issue: One or more replicas are not synchronized or have large queues.';
        PRINT 'Check network latency, disk I/O, and replica health. Consider failover or re-seeding.';

        SELECT 
            ag.name AS AG_Name,
            ar.replica_server_name,
            d.name AS DatabaseName,
            drs.synchronization_state_desc,
            drs.log_send_queue_size,
            drs.redo_queue_size,
            drs.suspend_reason_desc
        FROM sys.availability_groups ag
        JOIN sys.availability_replicas ar ON ag.group_id = ar.group_id
        JOIN sys.dm_hadr_database_replica_states drs ON ar.replica_id = drs.replica_id
        JOIN sys.databases d ON drs.database_id = d.database_id;
    END
    ELSE
    BEGIN
	    PRINT '   '
        PRINT N'‚úÖAG Health OK: All replicas synchronized and queues within normal range.';
    END
END
ELSE
BEGIN 
    PRINT '   '
    PRINT 'Skipped: This instance is not AG PRIMARY.';
END
------------------------------------------------------------------------------------
--9. DiskSpace
SET NOCOUNT ON
PRINT '   ';
PRINT '[--- Disk Space ---]';
PRINT '-------------------'

-- Always start fresh
IF OBJECT_ID('tempdb..#DiskInfo') IS NOT NULL DROP TABLE #DiskInfo;

-- Compute raw values (numeric for sorting)
SELECT DISTINCT
    CAST(SUBSTRING(ISNULL(volume_mount_point,''), 1, 20) AS NVARCHAR(20)) AS MountPoint,
    total_bytes     / 1024.0 / 1024 / 1024 AS TotalGB_num,
    available_bytes / 1024.0 / 1024 / 1024 AS AvailGB_num,
    CASE WHEN total_bytes > 0
         THEN available_bytes * 100.0 / total_bytes
         ELSE 0
    END AS Pct_num
INTO #DiskInfo
FROM sys.master_files AS f
CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.file_id);

-- Add severity and action (be consistent with names)
ALTER TABLE #DiskInfo ADD Severity NVARCHAR(12) NULL, Action NVARCHAR(40) NULL;

UPDATE #DiskInfo
SET Severity =
        CASE
            WHEN Pct_num < 10 THEN N'üî¥CRITICAL'
            WHEN Pct_num < 20 THEN N'üü† WARNING'
            ELSE N'üü¢ OK'
        END,
    Action =
        CASE
            WHEN Pct_num < 10 THEN N'Expand/move/archive now'
            WHEN Pct_num < 20 THEN N'Plan expand/archive'
            ELSE N'No action'
        END;

-- Compact display: fixed widths via STR() then LTRIM() to remove left padding
SELECT
    MountPoint                              AS MP,
    LTRIM(STR(TotalGB_num, 8, 2))           AS TotGB,    -- e.g.,  ' 123.45' -> '123.45'
    LTRIM(STR(AvailGB_num, 8, 2))           AS AvlGB,
    LTRIM(STR(Pct_num     , 6, 2)) + N'%'   AS FreePct,  -- e.g.,  ' 12.34' -> '12.34%'
    Severity                                AS Sev,
    Action                                   AS Act
FROM #DiskInfo
ORDER BY
    CASE WHEN Severity LIKE N'üî¥%' THEN 1 WHEN Severity LIKE N'üü†%' THEN 2 ELSE 3 END,
    Pct_num ASC;

-- Summary alerts
DECLARE @CriticalCount INT = (SELECT COUNT(*) FROM #DiskInfo WHERE Pct_num < 10);
DECLARE @WarningCount  INT = (SELECT COUNT(*) FROM #DiskInfo WHERE Pct_num >= 10 AND Pct_num < 20);

IF @CriticalCount > 0
    PRINT N'üî¥ ' + CAST(@CriticalCount AS NVARCHAR(10)) + N' vol(s) <10% free.';
IF @WarningCount > 0
    PRINT N'üü† ' + CAST(@WarningCount AS NVARCHAR(10)) + N' vol(s) 10‚Äì20% free.';
IF @CriticalCount = 0 AND @WarningCount = 0
    PRINT N'üü¢ All vols ‚â• 20% free.';
    PRINT '   ';
Drop table #DiskInfo
---------------------------------------------------------------------------------------------------
---10. Failed Jobs
PRINT '[--- Failed Jobs ---]';
PRINT '-------------------'

DECLARE @Since DATETIME = DATEADD(DAY, -1, GETDATE());

IF EXISTS (
    SELECT 1
    FROM msdb.dbo.sysjobhistory h
    WHERE h.run_status = 0
      AND h.step_id = 0
      AND DATETIMEFROMPARTS(h.run_date / 10000,
                            (h.run_date % 10000) / 100,
                            (h.run_date % 100),
                            h.run_time / 10000,
                            (h.run_time % 10000) / 100,
                            (h.run_time % 100),
                            0) >= @Since
)
BEGIN
    PRINT '   '
    PRINT N'‚ö†Ô∏è Issue: One or more jobs failed in the last 24 hours.';
	
    SELECT
        LEFT(j.name, 40) AS FailedJobName,
        h.step_id,
        DATEFROMPARTS(h.run_date / 10000,
                      (h.run_date % 10000) / 100,
                      (h.run_date % 100)) AS run_date_as_date,
        TIMEFROMPARTS(h.run_time / 10000,
                      (h.run_time % 10000) / 100,
                      (h.run_time % 100), 0, 0) AS run_time_as_time,
          h.message
    FROM msdb.dbo.sysjobhistory h
    JOIN msdb.dbo.sysjobs j ON h.job_id = j.job_id
    WHERE h.run_status = 0
      AND h.step_id = 0
      AND DATETIMEFROMPARTS(h.run_date / 10000,
                            (h.run_date % 10000) / 100,
                            (h.run_date % 100),
                            h.run_time / 10000,
                            (h.run_time % 10000) / 100,
                            (h.run_time % 100),
                            0) >= @Since
    ORDER BY run_time DESC;
END
ELSE
BEGIN
    PRINT '   '
    PRINT N'‚úÖAll SQL Agent jobs succeeded in the last 24 hours.';
END
------------------------------------------------------------------------
 --11. Busiest Databases
  PRINT '[--- Busiest Databases ---]'
  PRINT '--------------------------'

  GO
WITH db_stats AS (
    SELECT 
        DB_NAME(CAST(pa.value AS INT)) AS database_name,
        SUM(qs.execution_count) AS total_executions,
        SUM(qs.total_elapsed_time) AS total_elapsed_time,
        SUM(qs.total_worker_time) AS total_worker_time,
        SUM(qs.total_logical_reads) AS total_logical_reads,
        SUM(qs.total_logical_writes) AS total_logical_writes
    FROM 
        sys.dm_exec_query_stats AS qs
    CROSS APPLY 
        sys.dm_exec_plan_attributes(qs.plan_handle) AS pa
    WHERE 
        pa.attribute = 'dbid'
        AND DB_NAME(CAST(pa.value AS INT)) NOT IN ('master', 'msdb', 'model', 'tempdb')
    GROUP BY 
        pa.value
)
SELECT 
    SUBSTRING(database_name,1,40) AS DatabaseName,
       CAST(100.0 * total_elapsed_time / SUM(total_elapsed_time) OVER () AS DECIMAL(5,2)) AS PercentBusy,
    total_executions,
    total_elapsed_time,
    total_worker_time,
    total_logical_reads,
    total_logical_writes

FROM 
    db_stats
ORDER BY 
    PercentBusy DESC;

-------------------------------------------------------------------------
--12. Error Log Summary
PRINT '[--- SQL Server Error Log (Last 100 entries excluding successful logons) ---]';
PRINT '-----------------------------------------------------------------------------'

-- Create temp table
CREATE TABLE #ErrorLog (
    LogDate DATETIME,
    ProcessInfo NVARCHAR(255),
    Textdata NVARCHAR(MAX)
);

-- Insert all error log entries
INSERT INTO #ErrorLog
EXEC xp_readerrorlog 0, 1, NULL, NULL, NULL, NULL, N'desc';

-- Select top 100 excluding successful logons
SELECT TOP 100 
LogDate,
'' AS '-',
SUBSTRING(ProcessInfo,1,10)AS ProcessInfo,
Textdata AS ErrorLogDetails
FROM #ErrorLog
WHERE Textdata NOT LIKE '%Login succeeded%'
  AND Textdata NOT LIKE '%Login successful%'
ORDER BY LogDate DESC;

DROP TABLE #ErrorLog;
PRINT '   '
PRINT N'‚ö†Ô∏è Review above for repeated or critical errors. Investigate login failures, AG issues, or I/O errors.';
-------------------------------------------------------

--13. Database Status
PRINT '   '
PRINT '[--- Database Status ---]';
PRINT '-------------------------'

IF EXISTS (
    SELECT 1 FROM sys.databases WHERE state_desc <> 'ONLINE'
)
BEGIN
    PRINT '   '
    PRINT N'‚ö†Ô∏è Issue: One or more databases are not ONLINE.';
    PRINT 'Check for recovery issues, corruption, or intentional offline status.';

    SELECT 
	SUBSTRING(name,1,40) AS OfflineDatabase, 
	state_desc 
	FROM sys.databases WHERE state_desc <> 'ONLINE';
END
ELSE
BEGIN
    PRINT '   '
    PRINT N'‚úÖAll databases are ONLINE.';
END

--14. Wait issues
SET NOCOUNT ON
PRINT '   '
PRINT '[--- Investigate Waits ---]';

;WITH WaitInfo AS
(
    SELECT *
    FROM
    (
        VALUES
        -- wait_type, description, category, impact
        ('PAGEIOLATCH_EX', 'Disk I/O bottleneck on data pages; check storage latency, missing indexes, or excessive writes.', 'I/O', 'Slows down reads/writes; can cause query latency.'),
        ('PAGEIOLATCH_SH', 'Disk I/O bottleneck on shared data pages; investigate read-heavy workloads and storage performance.', 'I/O', 'Slows down read operations; affects OLTP and reporting queries.'),
        ('IO_COMPLETION', 'I/O completion waits; investigate disk subsystem latency or overloaded storage.', 'I/O', 'General I/O delay; can impact all workloads.'),
        ('LOGMGR_RESERVE_APPEND', 'Log manager waits; can indicate log file growth or disk latency. Check VLF fragmentation and log disk performance.', 'I/O', 'Slows down transaction commits; impacts write-heavy workloads.'),
        ('WRITELOG', 'Log flush waits; check disk latency or excessive logging.', 'I/O', 'Delays transaction commits; can cause blocking.'),
        ('ASYNC_NETWORK_IO', 'Client/network slow to consume results; investigate network throughput or client-side processing.', 'Network', 'Query completes but waits for client; can cause session blocking.'),
        ('CXPACKET', 'Parallelism waits; often due to skewed plans or MAXDOP settings.', 'CPU', 'Uneven parallelism; can waste CPU and slow queries.'),
        ('SOS_SCHEDULER_YIELD', 'CPU pressure; tasks yielding scheduler. Investigate CPU utilization and query efficiency.', 'CPU', 'Indicates CPU bottleneck; slows query execution.'),
        ('RESOURCE_SEMAPHORE', 'Query memory grant waits; memory pressure or large queries.', 'Memory', 'Delays query start; can cause concurrency issues.'),
        ('LCK_M_S', 'Shared lock waits; indicates blocking. Investigate queries holding locks too long or isolation level issues.', 'Locking', 'Blocks readers; can cause query timeouts.'),
        ('LCK_M_X', 'Exclusive lock waits; indicates blocking or contention.', 'Locking', 'Blocks writers; can cause severe blocking.'),
        ('MEMORY_ALLOCATION_EXT', 'Memory allocation waits; investigate memory pressure or large allocations.', 'Memory', 'Can slow query execution or cause spills.')
    ) AS W(wait_type, Description, Category, Impact)
),
ExcludedWaits AS
(
    SELECT wait_type FROM
    (
        VALUES
        ('SLEEP_TASK'), ('BROKER_TASK_STOP'), ('SQLTRACE_BUFFER_FLUSH'), ('CLR_SEMAPHORE'),
        ('LAZYWRITER_SLEEP'), ('RESOURCE_QUEUE'), ('XE_TIMER_EVENT'), ('XE_DISPATCHER_WAIT'),
        ('SOS_WORK_DISPATCHER'), ('HADR_WORK_QUEUE'), ('BROKER_TRANSMITTER'),
        ('SP_SERVER_DIAGNOSTICS_SLEEP'), ('HADR_NOTIFICATION_DEQUEUE'), ('DIRTY_PAGE_POLL'),
        ('FT_IFTS_SCHEDULER_IDLE_WAIT'), ('LOGMGR_QUEUE'), ('CHECKPOINT_QUEUE'),
        ('REQUEST_FOR_DEADLOCK_SEARCH'), ('BROKER_EVENTHANDLER'), ('BROKER_RECEIVE_WAITFOR'),
        ('DISPATCHER_QUEUE_SEMAPHORE'), ('FT_IFTSHC_MUTEX'), ('SQLTRACE_INCREMENTAL_FLUSH_SLEEP'),
        ('WAITFOR'), ('DBMIRROR_EVENTS_QUEUE'), ('DBMIRROR_WORKER_QUEUE'), ('DBMIRRORING_CMD'),
        ('HADR_CLUSAPI_CALL'), ('HADR_FILESTREAM_IOMGR_IOCOMPLETION'), ('QDS_PERSIST_TASK_MAIN_LOOP_SLEEP'),
        ('HADR_TIMER_TASK'), ('CLR_AUTO_EVENT'), ('BROKER_TO_FLUSH'), ('ONDEMAND_TASK_QUEUE'),
        ('PARALLEL_REDO_WORKER_WAIT_WORK'), ('HADR_LOGCAPTURE_WAIT'), ('REDO_THREAD_PENDING_WORK'),
        ('CXCONSUMER')
    ) AS E(wait_type)
)
SELECT TOP 15
   SUBSTRING(ws.wait_type,1,40) AS Wait_Type,
    STR(ws.wait_time_ms / 1000.0, 8, 2) AS wait_sec,
    STR(ws.signal_wait_time_ms / 1000.0, 8, 2) AS signal_wait_sec,
    ISNULL(wi.Category, 'Other') AS Category,
    ISNULL(wi.Description, 'Investigate: No specific description available.') AS Description,
    ISNULL(wi.Impact, 'Impact unknown; review workload.') AS Impact
FROM sys.dm_os_wait_stats AS ws
LEFT JOIN WaitInfo AS wi ON ws.wait_type = wi.wait_type
WHERE ws.wait_type NOT IN (SELECT wait_type FROM ExcludedWaits)
ORDER BY ws.wait_time_ms DESC;
PRINT '   '
PRINT N'‚ö†Ô∏è Only waits that may indicate performance issues are shown above. Review Category and Impact for troubleshooting guidance.';
PRINT '   '
---------------------------------------------------------------
--15. Check tempdb current useage
SET NOCOUNT ON;
SET ANSI_WARNINGS OFF;  -- Suppress NULL aggregate warning

DECLARE @PagesUsed BIGINT;

SELECT @PagesUsed = ISNULL(SUM(user_object_reserved_page_count), 0)
FROM sys.dm_db_file_space_usage;

IF @PagesUsed > 0
BEGIN
    PRINT '   '
    PRINT '[---TempDB User Object Usage---]';
	PRINT '--------------------------------'

    SELECT 
        ISNULL(SUM(user_object_reserved_page_count), 0) AS [UserObjectPagesUsed],
        (ISNULL(SUM(user_object_reserved_page_count), 0) * 1.0 / 128) AS [UserObjectSpaceMB]
    FROM sys.dm_db_file_space_usage;
END
ELSE
BEGIN 
  PRINT '[--- Tempdb Usage ---]   '
  PRINT N'‚ö†Ô∏èTEMPDB IS NOT CURRENTLY IN USE!'
END
SET ANSI_WARNINGS ON;   -- Restore default behavior
----------------------------------------------------------------------
--16.Top 10 CPU Consumers (Text-view aligned, with totals)
SET NOCOUNT ON;
PRINT '   '
PRINT '[---Top 10 CPU Consumers---]';
PRINT '----------------------------'

-- Fixed widths:
-- RowNo(5) | CPU_ms(12) | CPU_HHMMSS(12) | ExecCnt(9) | AvgCPU_ms(12) | %Inst(7) | QueryText(200)
DECLARE @Header NVARCHAR(400) =
    'RowNo CPU_ms      CPU_HHMMSS   ExecCnt   AvgCPU_ms   %Inst  QueryText';
DECLARE @Separator NVARCHAR(400) =
      REPLICATE('-',5)  + ' '
    + REPLICATE('-',12) + ' '
    + REPLICATE('-',12) + ' '
    + REPLICATE('-',9)  + ' '
    + REPLICATE('-',12) + ' '
    + REPLICATE('-',7)  + ' '
    + REPLICATE('-',200);

PRINT @Header;
PRINT @Separator;

;WITH Base AS (
    SELECT
        qs.total_worker_time            AS total_worker_us,         -- microseconds
        qs.execution_count              AS ExecCnt,
        t.[text]                        AS QueryText
    FROM sys.dm_exec_query_stats AS qs
    CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS t
),
Totals AS (
    SELECT 
        SUM(CAST(total_worker_us AS BIGINT)) / 1000 AS InstTotalCPU_ms  -- instance total in ms
    FROM Base
),
TopCpu AS (
    SELECT TOP 10
        ROW_NUMBER() OVER (ORDER BY b.total_worker_us DESC)         AS RowNo,
        CAST(b.total_worker_us / 1000 AS BIGINT)                    AS CPU_ms,
        b.ExecCnt,
        CASE WHEN b.ExecCnt > 0 
             THEN CAST((b.total_worker_us / 1000.0) / b.ExecCnt AS DECIMAL(20,2))
             ELSE CAST(0.0 AS DECIMAL(20,2))
        END                                                         AS AvgCPU_ms,
        b.QueryText
    FROM Base b
    ORDER BY b.total_worker_us DESC
),
WithPct AS (
    SELECT
        tc.*,
        CAST(
            CASE WHEN t.InstTotalCPU_ms > 0 
                 THEN (tc.CPU_ms * 100.0) / t.InstTotalCPU_ms 
                 ELSE 0.0 
            END AS DECIMAL(6,2)
        ) AS PctOfInstance
    FROM TopCpu tc
    CROSS JOIN Totals t
),
-- Helper to render HH:MM:SS from milliseconds (no DATEADD to avoid overflow)
Render AS (
    SELECT
        RowNo,
        CPU_ms,
        ExecCnt,
        AvgCPU_ms,
        PctOfInstance,
        QueryText,
        -- Convert ms -> seconds
        CAST(CPU_ms / 1000 AS BIGINT) AS TotalSeconds
    FROM WithPct
)
SELECT
    CONCAT(
        RIGHT(SPACE(5)  + CAST(RowNo AS VARCHAR(5)), 5), ' ',
        RIGHT(SPACE(12) + CAST(CPU_ms AS VARCHAR(12)), 12), ' ',
        -- HH:MM:SS (hours may exceed 99 on very busy systems; we cap width, not value)
        RIGHT(
            SPACE(12) + 
            CONCAT(
                -- Hours can exceed 24; show total hours
                CAST((TotalSeconds / 3600) AS VARCHAR(12)), ':',
                RIGHT('0' + CAST(((TotalSeconds % 3600) / 60) AS VARCHAR(2)), 2), ':',
                RIGHT('0' + CAST((TotalSeconds % 60) AS VARCHAR(2)), 2)
            )
        , 12), ' ',
        RIGHT(SPACE(9)  + CAST(ExecCnt AS VARCHAR(9)), 9), ' ',
        RIGHT(SPACE(12) + CAST(AvgCPU_ms AS VARCHAR(12)), 12), ' ',
        RIGHT(SPACE(7)  + CAST(PctOfInstance AS VARCHAR(7)), 7), ' ',
        LEFT(
            REPLACE(REPLACE(QueryText, CHAR(13)+CHAR(10), ' '), CHAR(9), ' ')
        , 80)
    ) AS [RowNo CPU_ms CPU_HHMMSS ExecCnt AvgCPU_ms %Inst QueryText]
FROM Render
ORDER BY RowNo;

-- Footer: totals for Top 10 and percent of instance
;WITH Base AS (
    SELECT
        qs.total_worker_time AS total_worker_us
    FROM sys.dm_exec_query_stats AS qs
),
Totals AS (
    SELECT SUM(CAST(total_worker_us AS BIGINT)) / 1000 AS InstTotalCPU_ms
    FROM Base
),
Top10 AS (
    SELECT TOP 10
        CAST(qs.total_worker_time / 1000 AS BIGINT) AS CPU_ms
    FROM sys.dm_exec_query_stats qs
    ORDER BY qs.total_worker_time DESC
),
Agg AS (
    SELECT 
        (SELECT SUM(CPU_ms) FROM Top10) AS Top10CPU_ms,
        t.InstTotalCPU_ms
    FROM Totals t
)
SELECT
    -- Print a clean footer line with totals
    CONCAT(
        'Top10 Total CPU (ms): ',
        CAST(Top10CPU_ms AS VARCHAR(30)),
        ' | Top10 Total CPU (HH:MM:SS): ',
        CONCAT(
            CAST((Top10CPU_ms/1000)/3600 AS VARCHAR(20)), ':',
            RIGHT('0' + CAST((((Top10CPU_ms/1000)%3600)/60) AS VARCHAR(2)), 2), ':',
            RIGHT('0' + CAST(((Top10CPU_ms/1000)%60) AS VARCHAR(2)), 2)
        ),
        ' | % of Instance CPU: ',
        CAST(CASE WHEN InstTotalCPU_ms>0 THEN (Top10CPU_ms*100.0)/InstTotalCPU_ms ELSE 0.0 END AS DECIMAL(6,2)),
        '%'
    ) AS [Summary]
FROM Agg;

----------------------------------------------------------------
--17. Index and Stats

PRINT '[--- Index and Statistics ---]'
PRINT '------------------------------'

SET NOCOUNT ON;
IF OBJECT_ID('tempdb..#IndexStats') IS NOT NULL DROP TABLE #IndexStats;
CREATE TABLE #IndexStats (
    DbName               sysname               NULL,
    ObjectName           sysname               NULL,
    IndexName            NVARCHAR(200)         NULL,  -- allow NULLs (heaps) or set placeholder in INSERT
    IndexType            NVARCHAR(60)          NULL,
    IsDisabled           bit                   NULL,
    IsHypothetical       bit                   NULL,
    LastIndexStatsUpdate datetime              NULL
);

DECLARE @sql nvarchar(max) = N'';

-- Build dynamic SQL for all online, writable user databases using FOR XML PATH
SELECT @sql = (
    SELECT '
USE ' + QUOTENAME(name) + ';
INSERT INTO #IndexStats (DbName, ObjectName, IndexName, IndexType, IsDisabled, IsHypothetical, LastIndexStatsUpdate)
SELECT
    DB_NAME() AS DbName,
    QUOTENAME(OBJECT_SCHEMA_NAME(i.object_id)) + ''.'' + QUOTENAME(OBJECT_NAME(i.object_id)) AS ObjectName,
    CASE 
        WHEN i.index_id = 0 THEN ''(HEAP)''
        ELSE ISNULL(i.name, ''(Unnamed)'')
    END AS IndexName,
    CASE i.type
        WHEN 0 THEN ''HEAP''
        WHEN 1 THEN ''CLUSTERED''
        WHEN 2 THEN ''NONCLUSTERED''
        WHEN 3 THEN ''XML''
        WHEN 4 THEN ''SPATIAL''
        WHEN 5 THEN ''CLUSTERED COLUMNSTORE''
        WHEN 6 THEN ''NONCLUSTERED COLUMNSTORE''
        WHEN 7 THEN ''NONCLUSTERED HASH''
        ELSE ''OTHER''
    END AS IndexType,
    i.is_disabled,
    i.is_hypothetical,
    STATS_DATE(i.object_id, i.index_id) AS LastIndexStatsUpdate
FROM sys.indexes AS i
WHERE i.object_id > 0
  AND OBJECTPROPERTY(i.object_id, ''IsMsShipped'') = 0
  AND i.index_id >= 0;
'
    FROM sys.databases
    WHERE database_id > 4              -- user databases only
      AND state = 0                    -- online
      AND is_read_only = 0             -- writable
    FOR XML PATH(''), TYPE
).value('.', 'NVARCHAR(MAX)');

-- Execute the dynamic SQL
EXEC sp_executesql @sql;

SET ANSI_WARNINGS OFF;
-- Instance-wide max last index stats update
PRINT '[Last Index Maintenance]';
SELECT MAX(LastIndexStatsUpdate) AS InstanceLastIndexMaintenance
FROM #IndexStats;

----------------------------------------------------------------
-- Per-database summary
SELECT 
    SUBSTRING(DbName,1,40) AS DatabaseName,
    MAX(LastIndexStatsUpdate) AS DbLastIndexStatsUpdate,
    SUM(CASE WHEN LastIndexStatsUpdate IS NOT NULL AND LastIndexStatsUpdate >= DATEADD(day, -1, SYSDATETIME()) THEN 1 ELSE 0 END) AS UpdatedLast24h,
    COUNT(*) AS TotalIndexes
FROM #IndexStats
GROUP BY DbName
ORDER BY DbName;
SET ANSI_WARNINGS ON;
-- Top 100  oldestindex maintenance (via stats updated)
PRINT 'Oldest Index Maintenance';
SELECT TOP 100
    SUBSTRING(DbName,1,40)AS DatabaseName,
    SUBSTRING(ObjectName,1,40) AS ObjectName,
    SUBSTRING(ISNULL(IndexName, '(HEAP)'),1,40) AS IndexName,
    LastIndexStatsUpdate
FROM #IndexStats
WHERE LastIndexStatsUpdate IS NOT NULL
ORDER BY LastIndexStatsUpdate ASC;
DROP TABLE #IndexStats
-------------------------------------------------

--18. Query Store Results

PRINT '[--- Query Store Status ---]';
PRINT '----------------------------'
SET NOCOUNT ON;

DECLARE @LookbackDays INT = 7;       -- Lookback window in days
DECLARE @TopN INT = 10;              -- Top N queries per metric per database
DECLARE @MinExecutions BIGINT = 5;   -- Minimum executions to include

/********************************************************************
A) Query Store status across databases
*********************************************************************/
IF OBJECT_ID('tempdb..#DbStatus') IS NOT NULL DROP TABLE #DbStatus;
CREATE TABLE #DbStatus (
    DatabaseId INT,
    DatabaseName SYSNAME,
    CompatibilityLevel INT,
    IsQueryStoreAvailable BIT,
    ActualStateDesc NVARCHAR(60) NULL,
    DesiredStateDesc NVARCHAR(60) NULL,
    IsQueryStoreEnabled BIT,
    IsReadOnly BIT
);

DECLARE @db SYSNAME, @dbid INT, @compat INT, @readonly BIT, @cmd NVARCHAR(MAX);

DECLARE dbs CURSOR LOCAL FAST_FORWARD FOR
SELECT name, database_id, compatibility_level, is_read_only
FROM sys.databases
WHERE database_id > 4      -- exclude master, tempdb, model, msdb
  AND state = 0;           -- ONLINE

OPEN dbs;
FETCH NEXT FROM dbs INTO @db, @dbid, @compat, @readonly;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @cmd = N'
BEGIN TRY
    USE ' + QUOTENAME(@db) + N';
    INSERT INTO #DbStatus (DatabaseId, DatabaseName, CompatibilityLevel, IsQueryStoreAvailable, ActualStateDesc, DesiredStateDesc, IsQueryStoreEnabled, IsReadOnly)
    SELECT
        ' + CAST(@dbid AS NVARCHAR(10)) + N',
        ' + QUOTENAME(@db,'''') + N',
        ' + CAST(@compat AS NVARCHAR(10)) + N',
        1,
        qso.actual_state_desc,
        qso.desired_state_desc,
        CASE WHEN qso.actual_state_desc IN (''READ_WRITE'',''READ_ONLY'') THEN 1 ELSE 0 END,
        ' + CAST(@readonly AS NVARCHAR(1)) + N'
    FROM sys.database_query_store_options AS qso;
END TRY
BEGIN CATCH
    INSERT INTO #DbStatus (DatabaseId, DatabaseName, CompatibilityLevel, IsQueryStoreAvailable, ActualStateDesc, DesiredStateDesc, IsQueryStoreEnabled, IsReadOnly)
    SELECT
        ' + CAST(@dbid AS NVARCHAR(10)) + N',
        ' + QUOTENAME(@db,'''') + N',
        ' + CAST(@compat AS NVARCHAR(10)) + N',
        0, NULL, NULL, 0, ' + CAST(@readonly AS NVARCHAR(1)) + N';
END CATCH;
';
    EXEC sys.sp_executesql @cmd;
    FETCH NEXT FROM dbs INTO @db, @dbid, @compat, @readonly;
END

CLOSE dbs;
DEALLOCATE dbs;


SELECT
    SUBSTRING(DatabaseName,1,40) AS DatabaseName,
    CompatibilityLevel,
    IsQueryStoreAvailable,
    SUBSTRING(ActualStateDesc,1,20) AS ActualStateDesc,
    SUBSTRING (DesiredStateDesc,1,20) AS DesiredStaeDesc,
    IsQueryStoreEnabled,
    IsReadOnly,
    StatusHighlight = CASE
        WHEN IsQueryStoreAvailable = 0 THEN N'‚ö†Ô∏èQuery Store not supported or inaccessible'
        WHEN IsQueryStoreEnabled = 0 THEN N'‚ö†Ô∏èQuery Store NOT enabled'
        WHEN ActualStateDesc = 'READ_ONLY' THEN 'Query Store read-only (capture stopped)'
        ELSE N'‚úÖQuery Store enabled'
    END
FROM #DbStatus
ORDER BY IsQueryStoreEnabled DESC, DatabaseName;


/********************************************************************
B) Worst queries from Query Store (last @LookbackDays days)
   - No reliance on sys.plan_attributes
*********************************************************************/
IF OBJECT_ID('tempdb..#WorstQueriesRaw') IS NOT NULL DROP TABLE #WorstQueriesRaw;
CREATE TABLE #WorstQueriesRaw (
    DatabaseName SYSNAME,
    QueryId BIGINT,
    PlanId BIGINT,
    QueryText NVARCHAR(MAX),
    ObjectName SYSNAME NULL,
    AvgDurationMs DECIMAL(18,2),
    AvgCPUms DECIMAL(18,2),
    AvgLogicalReads DECIMAL(18,2),
    ExecutionCount BIGINT,
    LastExecutionTime DATETIME2(3),
    MetricCategory VARCHAR(20)
);

DECLARE @StartTime DATETIME2(0) = DATEADD(DAY, -@LookbackDays, SYSUTCDATETIME());

DECLARE enabled CURSOR LOCAL FAST_FORWARD FOR
SELECT DatabaseName
FROM #DbStatus
WHERE IsQueryStoreAvailable = 1
  AND IsQueryStoreEnabled = 1;

OPEN enabled;
FETCH NEXT FROM enabled INTO @db;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @cmd = N'
BEGIN TRY
    USE ' + QUOTENAME(@db) + N';

    IF NOT EXISTS (
        SELECT 1
        FROM sys.database_query_store_options
        WHERE actual_state_desc IN (''READ_WRITE'', ''READ_ONLY'')
    )
        RETURN;

    ;WITH qs AS (
        SELECT
            q.query_id,
            p.plan_id,
            qt.query_sql_text,
            rs.count_executions AS exec_count,
            rs.avg_duration * 1000.0 AS avg_duration_ms,
            rs.avg_cpu_time * 1000.0 AS avg_cpu_ms,
            rs.avg_logical_io_reads AS avg_logical_reads,
            rs.last_execution_time
        FROM sys.query_store_query AS q
        JOIN sys.query_store_plan AS p ON p.query_id = q.query_id
        JOIN sys.query_store_query_text AS qt ON qt.query_text_id = q.query_text_id
        JOIN sys.query_store_runtime_stats AS rs ON rs.plan_id = p.plan_id
        JOIN sys.query_store_runtime_stats_interval AS rsi ON rsi.runtime_stats_interval_id = rs.runtime_stats_interval_id
        WHERE rsi.end_time >= @StartTime
          AND rs.count_executions >= @MinExecutions
    ),
    top_duration AS (
        SELECT TOP (@TopN) *
        FROM qs
        ORDER BY avg_duration_ms DESC
    ),
    top_cpu AS (
        SELECT TOP (@TopN) *
        FROM qs
        ORDER BY avg_cpu_ms DESC
    ),
    top_reads AS (
        SELECT TOP (@TopN) *
        FROM qs
        ORDER BY avg_logical_reads DESC
    )
    INSERT INTO #WorstQueriesRaw (DatabaseName, QueryId, PlanId, QueryText, ObjectName, AvgDurationMs, AvgCPUms, AvgLogicalReads, ExecutionCount, LastExecutionTime, MetricCategory)
    SELECT DB_NAME(), query_id, plan_id, query_sql_text, NULL, avg_duration_ms, avg_cpu_ms, avg_logical_reads, exec_count, last_execution_time, ''Duration'' FROM top_duration
    UNION ALL
    SELECT DB_NAME(), query_id, plan_id, query_sql_text, NULL, avg_duration_ms, avg_cpu_ms, avg_logical_reads, exec_count, last_execution_time, ''CPU'' FROM top_cpu
    UNION ALL
    SELECT DB_NAME(), query_id, plan_id, query_sql_text, NULL, avg_duration_ms, avg_cpu_ms, avg_logical_reads, exec_count, last_execution_time, ''Reads'' FROM top_reads;
END TRY
BEGIN CATCH
    RETURN;
END CATCH;
';
    EXEC sp_executesql
        @cmd,
        N'@StartTime DATETIME2(0), @TopN INT, @MinExecutions BIGINT',
        @StartTime=@StartTime, @TopN=@TopN, @MinExecutions=@MinExecutions;

    FETCH NEXT FROM enabled INTO @db;
END

CLOSE enabled;
DEALLOCATE enabled;

-- Deduplicate and store in #WorstQueries (no ORDER BY in SELECT INTO)
IF OBJECT_ID('tempdb..#WorstQueries') IS NOT NULL DROP TABLE #WorstQueries;

SELECT
    DatabaseName,
    QueryId,
    PlanId,
    QueryText,
    ObjectName,
    AvgDurationMs,
    AvgCPUms,
    AvgLogicalReads,
    ExecutionCount,
    LastExecutionTime,
    MetricCategory
INTO #WorstQueries
FROM (
    SELECT *,
           ROW_NUMBER() OVER (
                PARTITION BY DatabaseName, QueryId, PlanId
                ORDER BY 
                    CASE MetricCategory
                        WHEN 'Duration' THEN AvgDurationMs
                        WHEN 'CPU'     THEN AvgCPUms
                        WHEN 'Reads'   THEN AvgLogicalReads
                    END DESC
           ) AS rn
    FROM #WorstQueriesRaw
) AS x
WHERE rn = 1;

PRINT '==== Worst Queries from Query Store ====';
SELECT
    SUBSTRING(DatabaseName,1,40)AS DatabasName,
    MetricCategory,
    QueryId,
    PlanId,
    AvgDurationMs,
    AvgCPUms,
    AvgLogicalReads,
    ExecutionCount,
    LastExecutionTime,
    QueryText = CASE 
        WHEN LEN(QueryText) > 4000 THEN LEFT(QueryText, 4000) + N' ‚Ä¶(truncated)'
        ELSE QueryText
    END
FROM #WorstQueries
ORDER BY DatabaseName,
         MetricCategory,
         CASE MetricCategory
            WHEN 'Duration' THEN AvgDurationMs
            WHEN 'CPU'      THEN AvgCPUms
            WHEN 'Reads'    THEN AvgLogicalReads
         END DESC;
---------------------------------------------
PRINT '[=== End of Emergency Diagnostic ===]';
