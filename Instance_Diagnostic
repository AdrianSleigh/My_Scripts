
/* Fault Find a SQL Instance
   Run in Text format for easier reading
   V8.0 Last updated 26/11/25 -Adrian Sleigh
   Collects results to help identify current issues.
   GOTO labels with multi-selection
   - Set @SelectedItems = 'ALL' to run everything
   - Or pass a comma-separated list like '1,3,7,20'
   - Handles trimming, duplicates, invalid tokens, and out-of-range selections
   - SQL Server 2016 compatible.

[1]Instance Info [2]Current Connections [3]Page Life Expectancy [4]CPU Pressure [5]Blocking Sessions
[6]Transaction Log Usage Summary [7]Long-running Queries (>5 min) [8]Availability Group Health
[9]Disk Space [10]Failed Jobs [11]Busiest Databases [12]Last Used Database and Most used Object
[13]SQL Server Error Log (Last 100 entries excluding successful logons)
[14]Database Status [15]Investigate Waits [16]TempDB User Object Usage [17]Top 10 CPU Consumers 
[18]Index and Statistics
[19]Query Store Status INCLUDING Worst Queries from Query Store
[20]DDL Change Detection (Last 7 Days)


*/

SET NOCOUNT ON;

DECLARE @SelectedItems NVARCHAR(MAX) = 'ALL';  -- <-- set to 'ALL' or e.g. '1,3,7,20'

DECLARE @Work NVARCHAR(MAX);
DECLARE @CurrentItem INT;
DECLARE @pos INT;
DECLARE @token NVARCHAR(20);
DECLARE @sep NCHAR(1) = ',';

-- Expand ALL into 1..20 once
IF UPPER(LTRIM(RTRIM(@SelectedItems))) = 'ALL'
BEGIN
    SET @SelectedItems = '1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20';
END

-- Optional: normalize spaces
SET @SelectedItems = REPLACE(@SelectedItems, ' ', '');

-- Optional: remove duplicated selections by loading into a table
IF OBJECT_ID('tempdb..#Sel') IS NOT NULL DROP TABLE #Sel;
CREATE TABLE #Sel (ItemID INT PRIMARY KEY);

-- Tokenize @SelectedItems and insert distinct ints to #Sel
SET @Work = @SelectedItems;

Tokenize:
    IF @Work IS NULL OR @Work = '' GOTO TokenizeDone;

    SET @pos = CHARINDEX(@sep, @Work);
    IF @pos > 0
        SET @token = SUBSTRING(@Work, 1, @pos - 1);
    ELSE
        SET @token = @Work;

    IF TRY_CONVERT(INT, @token) IS NOT NULL
    BEGIN
        SET @CurrentItem = CONVERT(INT, @token);
        IF @CurrentItem BETWEEN 1 AND 20
        BEGIN
            -- Insert distinct; ignore duplicates
            IF NOT EXISTS (SELECT 1 FROM #Sel WHERE ItemID = @CurrentItem)
                INSERT INTO #Sel (ItemID) VALUES (@CurrentItem);
        END
        ELSE
        BEGIN
            PRINT CONCAT('Skipping out-of-range selection (1-20): ', @CurrentItem);
        END
    END
    ELSE
    BEGIN
        PRINT CONCAT('Skipping invalid selection: "', @token, '"');
    END

    IF @pos > 0
        SET @Work = SUBSTRING(@Work, @pos + 1, LEN(@Work));
    ELSE
        SET @Work = NULL;

    GOTO Tokenize;

TokenizeDone:
    -- Cursor-free loop across selected items in ascending order
    DECLARE @NextItem INT;

GetNext:
    SELECT TOP (1) @NextItem = ItemID
    FROM #Sel
    ORDER BY ItemID;  -- Change to desired order

    IF @NextItem IS NULL GOTO EndScript;

    -- Route to specific item block
    IF @NextItem = 1  GOTO Item1;
    IF @NextItem = 2  GOTO Item2;
    IF @NextItem = 3  GOTO Item3;
    IF @NextItem = 4  GOTO Item4;
    IF @NextItem = 5  GOTO Item5;
    IF @NextItem = 6  GOTO Item6;
    IF @NextItem = 7  GOTO Item7;
    IF @NextItem = 8  GOTO Item8;
    IF @NextItem = 9  GOTO Item9;
    IF @NextItem = 10 GOTO Item10;
    IF @NextItem = 11 GOTO Item11;
    IF @NextItem = 12 GOTO Item12;
    IF @NextItem = 13 GOTO Item13;
    IF @NextItem = 14 GOTO Item14;
    IF @NextItem = 15 GOTO Item15;
    IF @NextItem = 16 GOTO Item16;
    IF @NextItem = 17 GOTO Item17;
    IF @NextItem = 18 GOTO Item18;
    IF @NextItem = 19 GOTO Item19;
	IF @NextItem = 20 GOTO Item20;   

    -- Should never reach here
    PRINT CONCAT('No handler for item: ', @NextItem);
    GOTO AfterItem;

--------------------------
-- Item blocks (put your code in each and end by removing @NextItem and GOTO GetNext)
--------------------------

Item1:

SET NOCOUNT ON;
PRINT N'=== üìä SQL Server Diagnostic Script ===';
PRINT '[1--- Instance Info ---]'
--1. Instance Info
SELECT
    'INSTANCE NAME ' + 
    @@SERVERNAME + 
    ' | Last SQL Restart: ' + 
    CONVERT(VARCHAR, sqlserver_start_time, 120) + 
    ' | UPTIME: ' + 
    CAST(DATEDIFF(SECOND, sqlserver_start_time, GETDATE()) / 86400 AS VARCHAR) + ' days, ' +
    CAST((DATEDIFF(SECOND, sqlserver_start_time, GETDATE()) % 86400) / 3600 AS VARCHAR) + ' hours, ' +
    CAST((DATEDIFF(SECOND, sqlserver_start_time, GETDATE()) % 3600) / 60 AS VARCHAR) + ' minutes'
FROM sys.dm_os_sys_info;


    GOTO AfterItem;
-----------------------------------------------------
Item2:
  
      --2. DMV-based simplified sp_who2 with ProgramName, Blocking Info, excluding system and SA
PRINT '[2.--- Current Connections ---]';
PRINT '-------------------------------------'

SELECT 
    s.session_id AS [SPID],
    s.status,
   SUBSTRING(s.login_name,1,30) AS [Login],
   SUBSTRING(s.host_name,1,30) AS [HostName],
   SUBSTRING(DB_NAME(r.database_id),1,30) AS [DBName],
    r.command AS [Command],
    r.cpu_time AS [CPUTime],
    r.reads + r.writes AS [DiskIO],
    s.last_request_end_time AS [LastBatch],
   SUBSTRING(s.program_name,1,70) AS [ProgramName],
    r.blocking_session_id AS [BlockedBy],
    CASE 
        WHEN EXISTS (
            SELECT 1 FROM sys.dm_exec_requests WHERE blocking_session_id = s.session_id
        ) THEN 'Yes' ELSE 'No'
    END AS [IsBlockingOthers]
FROM sys.dm_exec_sessions AS s
LEFT JOIN sys.dm_exec_requests AS r ON s.session_id = r.session_id
WHERE s.session_id <> @@SPID
  AND s.is_user_process = 1              -- Exclude system sessions
  AND s.login_name <> 'NT AUTHORITY\SYSTEM'
  AND s.login_name <> 'sa'               -- SA
  AND s.login_name <> 'moxireader'       -- Excludes
ORDER BY r.cpu_time DESC;

    GOTO AfterItem;
------------------------------------------------------
Item3:

    PRINT '[3.--- Page Life Expectancy ---]';
    PRINT '-------------------------------------'
	--3. Page Life Expectancy
SET NOCOUNT ON
DECLARE @PLE INT;

SELECT @PLE = cntr_value
FROM sys.dm_os_performance_counters
WHERE object_name LIKE '%Buffer Manager%'
  AND counter_name = 'Page life expectancy';

SELECT
    @PLE AS PageLifeExpectancy,
    cntr_value AS PageLifeValue,
    RIGHT('0' + CAST(cntr_value / 3600 AS VARCHAR(10)), 2) + ':' +
    RIGHT('0' + CAST((cntr_value % 3600) / 60 AS VARCHAR(10)), 2) + ':' +
    RIGHT('0' + CAST(cntr_value % 60 AS VARCHAR(10)), 2) AS TimeHMS
FROM sys.dm_os_performance_counters
WHERE object_name LIKE '%Buffer Manager%'
  AND counter_name = 'Page life expectancy';

IF @PLE < 500

BEGIN
    PRINT N'‚ö†Ô∏è Warning: Page Life Expectancy is below 500.';
    PRINT 'Investigate memory pressure, buffer pool churn, or large query workloads. Consider reviewing memory settings and query patterns.';
END
ELSE
BEGIN
    PRINT N'‚úÖ Page Life Expectancy is within acceptable range.';
END
    
    GOTO AfterItem;
--------------------------------------------------------
Item4:

      --4. CPU Pressure
PRINT '   '
PRINT '[4.--- CPU Pressure ---]';
PRINT '---------------------------'

SELECT 
    total_physical_memory_kb / 1024 AS TotalMemoryMB,
    available_physical_memory_kb / 1024 AS AvailableMemoryMB,
    SUBSTRING(system_memory_state_desc,1,40)AS System_Memory_Desc
FROM sys.dm_os_sys_memory;

    GOTO AfterItem;
----------------------------------------------
Item5:

 --5. Blocking Sessions
  PRINT '[5.--- Blocking Sessions ---]';
  PRINT '--------------------------------'

IF EXISTS (SELECT 1 FROM sys.dm_exec_requests WHERE blocking_session_id <> 0)
BEGIN 
    PRINT '   '
    PRINT N'‚ö†Ô∏è Issue: Blocking detected.';
    PRINT 'Identify root blocker. If safe, kill session or tune query/index.';

    SELECT 
        r.session_id,
        r.blocking_session_id,
        r.wait_type,
        r.wait_time,
        t.text AS sql_text
    FROM sys.dm_exec_requests r
    CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
    WHERE r.blocking_session_id <> 0;
END
ELSE
BEGIN
    PRINT '   '
    PRINT N'‚úÖ No blocking sessions detected.';
END
    GOTO AfterItem;

------------------------------------------

Item6:
-- 6. Transaction Log Usage

PRINT '   ';
PRINT '[6.---Transaction Log Usage Summary---]';
PRINT '--------------------------------------';

SET NOCOUNT ON;
DECLARE @Threshold INT = 80;  -- change this to your preferred warning threshold (percent)

IF OBJECT_ID('tempdb..#LogSpace') IS NOT NULL DROP TABLE #LogSpace;
CREATE TABLE #LogSpace (
    DatabaseName sysname,
    LogSizeMB    DECIMAL(18,2),
    LogUsedPct   DECIMAL(18,2),
    Status       INT
);

-- Capture log usage for all databases
INSERT INTO #LogSpace (DatabaseName, LogSizeMB, LogUsedPct, Status)
EXEC ('DBCC SQLPERF(LOGSPACE)');

-- Optional: Exclude offline or restoring DBs
;WITH DbStates AS (
    SELECT d.name, d.state
    FROM sys.databases AS d
)
DELETE ls
FROM #LogSpace AS ls
JOIN DbStates AS ds ON ds.name = ls.DatabaseName
WHERE ds.state <> 0;  -- keep only ONLINE databases

SELECT 
    SUBSTRING(DatabaseName,1,40) AS [Database],
    LogSizeMB    AS [Log Size (MB)],
    LogUsedPct   AS [Used %],
    CASE Status WHEN 0 THEN 'ONLINE' ELSE CAST(Status AS VARCHAR(10)) END AS [Status]
FROM #LogSpace
ORDER BY LogUsedPct DESC, DatabaseName;

-- Warnings for high usage
DECLARE @WarnCount INT = 0;

SELECT @WarnCount = COUNT(*)
FROM #LogSpace
WHERE LogUsedPct >= @Threshold;

IF @WarnCount > 0
BEGIN
    PRINT N'‚ö†Ô∏è--- WARNINGS ---';
    SELECT 
        CONCAT(
            'WARNING: ', DatabaseName, ' log usage is ',
            CAST(LogUsedPct AS VARCHAR(10)), '% (size ',
            CAST(LogSizeMB AS VARCHAR(20)), ' MB). Consider log backup/checkpoint/investigate long-running transactions.'
        ) AS [Warning]
    FROM #LogSpace
    WHERE LogUsedPct >= @Threshold
    ORDER BY LogUsedPct DESC;
END
ELSE
BEGIN
    PRINT N'‚úÖ All databases are below the transaction log usage threshold.';
END
    GOTO AfterItem;

------------------------------------------------------
Item7:

--7. Long-running Queries
PRINT '   '
PRINT '[7.--- Long-running Queries (>5 min) ---]';
PRINT '----------------------------------------'

IF EXISTS (
    SELECT 1
    FROM sys.dm_exec_requests r
    CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
    WHERE r.total_elapsed_time > 300000
      AND t.text NOT LIKE '%sp_server_diagnostics%'
)
BEGIN
    PRINT '   '
    PRINT '‚ö†Ô∏è Long-running request detected (excluding sp_server_diagnostics).';

    SELECT 
        N'‚ö†Ô∏è' AS LongRunningQuery,
        r.session_id,
        r.total_elapsed_time / 1000 AS ElapsedSec,
        SUBSTRING(t.text, 1, 100) AS sql_text
    FROM sys.dm_exec_requests r
    CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
    WHERE r.total_elapsed_time > 300000
      AND t.text NOT LIKE '%sp_server_diagnostics%';
END
ELSE
BEGIN
    PRINT '   '
    PRINT N'‚úÖ No long-running queries over 5 minutes.';
END
 
    GOTO AfterItem;

-------------------------------------------------
Item8:

--8.  Availability Group Health
PRINT '   '
PRINT '[8.--- Availability Group Health ---]';
PRINT  '-----------------------------------'

IF EXISTS (
    SELECT 1 FROM sys.dm_hadr_availability_replica_states WHERE role_desc = 'PRIMARY'
)
BEGIN
    IF EXISTS (
        SELECT 1
        FROM sys.dm_hadr_database_replica_states
        WHERE synchronization_state_desc <> 'SYNCHRONIZED'
           OR log_send_queue_size > 10000
           OR redo_queue_size > 10000
    )
    BEGIN 
	    PRINT '   '
        PRINT N'‚ö†Ô∏è Issue: One or more replicas are not synchronized or have large queues.';
        PRINT 'Check network latency, disk I/O, and replica health. Consider failover or re-seeding.';

        SELECT 
            ag.name AS AG_Name,
            ar.replica_server_name,
            d.name AS DatabaseName,
            drs.synchronization_state_desc,
            drs.log_send_queue_size,
            drs.redo_queue_size,
            drs.suspend_reason_desc
        FROM sys.availability_groups ag
        JOIN sys.availability_replicas ar ON ag.group_id = ar.group_id
        JOIN sys.dm_hadr_database_replica_states drs ON ar.replica_id = drs.replica_id
        JOIN sys.databases d ON drs.database_id = d.database_id;
    END
    ELSE
    BEGIN
	    PRINT '   '
        PRINT N'‚úÖ AG Health OK: All replicas synchronized and queues within normal range.';
    END
END
ELSE
BEGIN 
    PRINT '   '
    PRINT 'Skipped: This instance is not AG PRIMARY.';
END
    GOTO AfterItem;

-----------------------------------------------
Item9:

--9. DiskSpace
SET NOCOUNT ON
PRINT '   ';
PRINT '[9.--- Disk Space ---]';
PRINT '-----------------------'

-- Always start fresh
IF OBJECT_ID('tempdb..#DiskInfo') IS NOT NULL DROP TABLE #DiskInfo;

-- Compute raw values (numeric for sorting)
SELECT DISTINCT
    CAST(SUBSTRING(ISNULL(volume_mount_point,''), 1, 20) AS NVARCHAR(20)) AS MountPoint,
    total_bytes     / 1024.0 / 1024 / 1024 AS TotalGB_num,
    available_bytes / 1024.0 / 1024 / 1024 AS AvailGB_num,
    CASE WHEN total_bytes > 0
         THEN available_bytes * 100.0 / total_bytes
         ELSE 0
    END AS Pct_num
INTO #DiskInfo
FROM sys.master_files AS f
CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.file_id);

-- Add severity and action (be consistent with names)
ALTER TABLE #DiskInfo ADD Severity NVARCHAR(12) NULL, Action NVARCHAR(40) NULL;

UPDATE #DiskInfo
SET Severity =
        CASE
            WHEN Pct_num < 10 THEN N'üî¥CRITICAL'
            WHEN Pct_num < 20 THEN N'üü† WARNING'
            ELSE N'üü¢ OK'
        END,
    Action =
        CASE
            WHEN Pct_num < 10 THEN N'Expand/move/archive now'
            WHEN Pct_num < 20 THEN N'Plan expand/archive'
            ELSE N'No action'
        END;

-- Compact display: fixed widths via STR() then LTRIM() to remove left padding
SELECT
    MountPoint                              AS MP,
    LTRIM(STR(TotalGB_num, 8, 2))           AS TotGB,    -- e.g.,  ' 123.45' -> '123.45'
    LTRIM(STR(AvailGB_num, 8, 2))           AS AvlGB,
    LTRIM(STR(Pct_num     , 6, 2)) + N'%'   AS FreePct,  -- e.g.,  ' 12.34' -> '12.34%'
    Severity                                AS Sev,
    Action                                   AS Act
FROM #DiskInfo
ORDER BY
    CASE WHEN Severity LIKE N'üî¥%' THEN 1 WHEN Severity LIKE N'üü†%' THEN 2 ELSE 3 END,
    Pct_num ASC;

-- Summary alerts
DECLARE @CriticalCount INT = (SELECT COUNT(*) FROM #DiskInfo WHERE Pct_num < 10);
DECLARE @WarningCount  INT = (SELECT COUNT(*) FROM #DiskInfo WHERE Pct_num >= 10 AND Pct_num < 20);

IF @CriticalCount > 0
    PRINT N'üî¥ ' + CAST(@CriticalCount AS NVARCHAR(10)) + N' vol(s) <10% free.';
IF @WarningCount > 0
    PRINT N'üü† ' + CAST(@WarningCount AS NVARCHAR(10)) + N' vol(s) 10‚Äì20% free.';
IF @CriticalCount = 0 AND @WarningCount = 0
    PRINT N'üü¢ All vols ‚â• 20% free.';
    PRINT '   ';
Drop table #DiskInfo
    GOTO AfterItem;

------------------------------------------
Item10:

 ---10. Failed Jobs
PRINT '[10.--- Failed Jobs ---]';
PRINT '-----------------------'

DECLARE @Since DATETIME = DATEADD(DAY, -1, GETDATE());

IF EXISTS (
    SELECT 1
    FROM msdb.dbo.sysjobhistory h
    WHERE h.run_status = 0
      AND h.step_id = 0
      AND DATETIMEFROMPARTS(h.run_date / 10000,
                            (h.run_date % 10000) / 100,
                            (h.run_date % 100),
                            h.run_time / 10000,
                            (h.run_time % 10000) / 100,
                            (h.run_time % 100),
                            0) >= @Since
)
BEGIN
    PRINT '   '
    PRINT N'‚ö†Ô∏è Issue: One or more jobs failed in the last 24 hours.';
	
    SELECT
        LEFT(j.name, 40) AS FailedJobName,
        h.step_id,
        DATEFROMPARTS(h.run_date / 10000,
                      (h.run_date % 10000) / 100,
                      (h.run_date % 100)) AS run_date_as_date,
        TIMEFROMPARTS(h.run_time / 10000,
                      (h.run_time % 10000) / 100,
                      (h.run_time % 100), 0, 0) AS run_time_as_time,
          h.message
    FROM msdb.dbo.sysjobhistory h
    JOIN msdb.dbo.sysjobs j ON h.job_id = j.job_id
    WHERE h.run_status = 0
      AND h.step_id = 0
      AND DATETIMEFROMPARTS(h.run_date / 10000,
                            (h.run_date % 10000) / 100,
                            (h.run_date % 100),
                            h.run_time / 10000,
                            (h.run_time % 10000) / 100,
                            (h.run_time % 100),
                            0) >= @Since
    ORDER BY run_time DESC;
END
ELSE
BEGIN
    PRINT '   '
    PRINT N'‚úÖ All SQL Agent jobs succeeded in the last 24 hours.';
	PRINT '   ';
END

    GOTO AfterItem;

--------------------------------------------
Item11:

 --11. Busiest Databases
  PRINT '[11.--- Busiest Databases ---]'
  PRINT '-----------------------------';

 -- GO
WITH db_stats AS (
    SELECT 
        DB_NAME(CAST(pa.value AS INT)) AS database_name,
        SUM(qs.execution_count) AS total_executions,
        SUM(qs.total_elapsed_time) AS total_elapsed_time,
        SUM(qs.total_worker_time) AS total_worker_time,
        SUM(qs.total_logical_reads) AS total_logical_reads,
        SUM(qs.total_logical_writes) AS total_logical_writes
    FROM 
        sys.dm_exec_query_stats AS qs
    CROSS APPLY 
        sys.dm_exec_plan_attributes(qs.plan_handle) AS pa
    WHERE 
        pa.attribute = 'dbid'
        AND DB_NAME(CAST(pa.value AS INT)) NOT IN ('master', 'msdb', 'model', 'tempdb')
    GROUP BY 
        pa.value
)
SELECT 
    SUBSTRING(database_name,1,40) AS DatabaseName,
       CAST(100.0 * total_elapsed_time / SUM(total_elapsed_time) OVER () AS DECIMAL(5,2)) AS PercentBusy,
    total_executions,
    total_elapsed_time,
    total_worker_time,
    total_logical_reads,
    total_logical_writes

FROM 
    db_stats
ORDER BY 
    PercentBusy DESC;
    GOTO AfterItem;

--------------------------------------------
Item12:

--12. Last Used Databases and Most used object per database
PRINT '[12.--- Last Used Database and Most used Object ---]';
PRINT '----------------------------------------------------'

SET NOCOUNT ON;
SET ANSI_WARNINGS OFF;

-- Temporary table for database usage
IF OBJECT_ID('tempdb..#DbUsage1') IS NOT NULL DROP TABLE #DbUsage1;
CREATE TABLE #DbUsage1 (
    DatabaseName SYSNAME,
    LastUserSeek DATETIME NULL,
    LastUserScan DATETIME NULL,
    LastUserLookup DATETIME NULL,
    LastUserUpdate DATETIME NULL
);

INSERT INTO #DbUsage1
SELECT 
    DB_NAME(database_id) AS DatabaseName,
    MAX(last_user_seek) AS LastUserSeek,
    MAX(last_user_scan) AS LastUserScan,
    MAX(last_user_lookup) AS LastUserLookup,
    MAX(last_user_update) AS LastUserUpdate
FROM sys.dm_db_index_usage_stats
WHERE database_id > 4 -- exclude system DBs
GROUP BY database_id;

-- Temporary table for object usage
IF OBJECT_ID('tempdb..#ObjectUsage1') IS NOT NULL DROP TABLE #ObjectUsage1;
CREATE TABLE #ObjectUsage1 (
    DatabaseName SYSNAME NULL,
    ObjectName SYSNAME NULL,
    ExecutionCount BIGINT NULL,
    LastExecutionTime DATETIME NULL,
    SQLText NVARCHAR(MAX) NULL
);

INSERT INTO #ObjectUsage1
SELECT 
    DB_NAME(st.dbid) AS DatabaseName,
    OBJECT_NAME(st.objectid, st.dbid) AS ObjectName,
    qs.execution_count AS ExecutionCount,
    qs.last_execution_time,
    st.text AS SQLText
FROM sys.dm_exec_query_stats AS qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
WHERE st.dbid > 4 -- exclude system DBs
  AND DB_NAME(st.dbid) IS NOT NULL; -- filter out NULL database names

-- Final combined report
SELECT 
    SUBSTRING(d.DatabaseName,1,40) AS DatabaseName,
    COALESCE(CONVERT(VARCHAR(19), d.LastUserSeek, 120), 'Never') AS LastUserSeek,
    COALESCE(CONVERT(VARCHAR(19), d.LastUserScan, 120), 'Never') AS LastUserScan,
    COALESCE(CONVERT(VARCHAR(19), d.LastUserLookup, 120), 'Never') AS LastUserLookup,
    COALESCE(CONVERT(VARCHAR(19), d.LastUserUpdate, 120), 'Never') AS LastUserUpdate,
    SUBSTRING(o.ObjectName,1,40)AS MostUsedObjectName,
    o.ExecutionCount,
    COALESCE(CONVERT(VARCHAR(19), o.LastExecutionTime, 120), 'Never') AS LastExecutionTime
FROM #DbUsage1 d
LEFT JOIN (
    SELECT DatabaseName, ObjectName, ExecutionCount, LastExecutionTime
    FROM (
        SELECT *,
               ROW_NUMBER() OVER (PARTITION BY DatabaseName ORDER BY LastExecutionTime DESC) AS rn
        FROM #ObjectUsage1
    ) t
    WHERE rn = 1 -- Top 5 objects per database
) o ON d.DatabaseName = o.DatabaseName
ORDER BY d.DatabaseName, o.LastExecutionTime DESC;
--DROP TABLE #DbUsage1
SET ANSI_WARNINGS ON;
    GOTO AfterItem;
-----------------------------------------------
Item13:
  
  --13. Error Log Summary
PRINT '[13.--- SQL Server Error Log (Last 100 entries excluding successful logons) ---]';
PRINT '-------------------------------------------------------------------------------'

-- Create temp table
CREATE TABLE #ErrorLog (
    LogDate DATETIME,
    ProcessInfo NVARCHAR(255),
    Textdata NVARCHAR(MAX)
);

-- Insert all error log entries
INSERT INTO #ErrorLog
EXEC xp_readerrorlog 0, 1, NULL, NULL, NULL, NULL, N'desc';

-- Select top 100 excluding successful logons
SELECT TOP 100 
LogDate,
'' AS '-',
SUBSTRING(ProcessInfo,1,10)AS ProcessInfo,
Textdata AS ErrorLogDetails
FROM #ErrorLog
WHERE Textdata NOT LIKE '%Login succeeded%'
  AND Textdata NOT LIKE '%Login successful%'
ORDER BY LogDate DESC;

DROP TABLE #ErrorLog;
PRINT '   '
PRINT N'‚ö†Ô∏è Review above for repeated or critical errors. Investigate login failures, AG issues, or I/O errors.';
    GOTO AfterItem;

----------------------------------------------
Item14:

  --14. Database Status
PRINT '   '
PRINT '[14.--- Database Status ---]';
PRINT '---------------------------'

IF EXISTS (
    SELECT 1 FROM sys.databases WHERE state_desc <> 'ONLINE'
)
BEGIN
    PRINT '   '
    PRINT N'‚ö†Ô∏è Issue: One or more databases are not ONLINE.';
    PRINT 'Check for recovery issues, corruption, or intentional offline status.';

    SELECT 
	SUBSTRING(name,1,40) AS OfflineDatabase, 
	state_desc 
	FROM sys.databases WHERE state_desc <> 'ONLINE';
END
ELSE
BEGIN
    PRINT '   '
    PRINT N'‚úÖ All databases are ONLINE.';
END

    GOTO AfterItem;

-----------------------------------------------
Item15:

--15. Wait issues
SET NOCOUNT ON
PRINT '   '
PRINT '[15.--- Investigate Waits ---]';
PRINT '-----------------------------'

;WITH WaitInfo AS
(
    SELECT *
    FROM
    (
        VALUES
        -- wait_type, description, category, impact
        ('PAGEIOLATCH_EX', 'Disk I/O bottleneck on data pages; check storage latency, missing indexes, or excessive writes.', 'I/O', 'Slows down reads/writes; can cause query latency.'),
        ('PAGEIOLATCH_SH', 'Disk I/O bottleneck on shared data pages; investigate read-heavy workloads and storage performance.', 'I/O', 'Slows down read operations; affects OLTP and reporting queries.'),
        ('IO_COMPLETION', 'I/O completion waits; investigate disk subsystem latency or overloaded storage.', 'I/O', 'General I/O delay; can impact all workloads.'),
        ('LOGMGR_RESERVE_APPEND', 'Log manager waits; can indicate log file growth or disk latency. Check VLF fragmentation and log disk performance.', 'I/O', 'Slows down transaction commits; impacts write-heavy workloads.'),
        ('WRITELOG', 'Log flush waits; check disk latency or excessive logging.', 'I/O', 'Delays transaction commits; can cause blocking.'),
        ('ASYNC_NETWORK_IO', 'Client/network slow to consume results; investigate network throughput or client-side processing.', 'Network', 'Query completes but waits for client; can cause session blocking.'),
        ('CXPACKET', 'Parallelism waits; often due to skewed plans or MAXDOP settings.', 'CPU', 'Uneven parallelism; can waste CPU and slow queries.'),
        ('SOS_SCHEDULER_YIELD', 'CPU pressure; tasks yielding scheduler. Investigate CPU utilization and query efficiency.', 'CPU', 'Indicates CPU bottleneck; slows query execution.'),
        ('RESOURCE_SEMAPHORE', 'Query memory grant waits; memory pressure or large queries.', 'Memory', 'Delays query start; can cause concurrency issues.'),
        ('LCK_M_S', 'Shared lock waits; indicates blocking. Investigate queries holding locks too long or isolation level issues.', 'Locking', 'Blocks readers; can cause query timeouts.'),
        ('LCK_M_X', 'Exclusive lock waits; indicates blocking or contention.', 'Locking', 'Blocks writers; can cause severe blocking.'),
        ('MEMORY_ALLOCATION_EXT', 'Memory allocation waits; investigate memory pressure or large allocations.', 'Memory', 'Can slow query execution or cause spills.')
    ) AS W(wait_type, Description, Category, Impact)
),
ExcludedWaits AS
(
    SELECT wait_type FROM
    (
        VALUES
        ('SLEEP_TASK'), ('BROKER_TASK_STOP'), ('SQLTRACE_BUFFER_FLUSH'), ('CLR_SEMAPHORE'),
        ('LAZYWRITER_SLEEP'), ('RESOURCE_QUEUE'), ('XE_TIMER_EVENT'), ('XE_DISPATCHER_WAIT'),
        ('SOS_WORK_DISPATCHER'), ('HADR_WORK_QUEUE'), ('BROKER_TRANSMITTER'),
        ('SP_SERVER_DIAGNOSTICS_SLEEP'), ('HADR_NOTIFICATION_DEQUEUE'), ('DIRTY_PAGE_POLL'),
        ('FT_IFTS_SCHEDULER_IDLE_WAIT'), ('LOGMGR_QUEUE'), ('CHECKPOINT_QUEUE'),
        ('REQUEST_FOR_DEADLOCK_SEARCH'), ('BROKER_EVENTHANDLER'), ('BROKER_RECEIVE_WAITFOR'),
        ('DISPATCHER_QUEUE_SEMAPHORE'), ('FT_IFTSHC_MUTEX'), ('SQLTRACE_INCREMENTAL_FLUSH_SLEEP'),
        ('WAITFOR'), ('DBMIRROR_EVENTS_QUEUE'), ('DBMIRROR_WORKER_QUEUE'), ('DBMIRRORING_CMD'),
        ('HADR_CLUSAPI_CALL'), ('HADR_FILESTREAM_IOMGR_IOCOMPLETION'), ('QDS_PERSIST_TASK_MAIN_LOOP_SLEEP'),
        ('HADR_TIMER_TASK'), ('CLR_AUTO_EVENT'), ('BROKER_TO_FLUSH'), ('ONDEMAND_TASK_QUEUE'),
        ('PARALLEL_REDO_WORKER_WAIT_WORK'), ('HADR_LOGCAPTURE_WAIT'), ('REDO_THREAD_PENDING_WORK'),
        ('CXCONSUMER'),('PREEMPTIVE_OS_DEVICEOPS'),('PREEMPTIVE_OS_AUTHENTICATIONOPS'),('MSQL_XP'),
		('PREEMPTIVE_OS_AUTHORIZATIONOPS'),('PREEMPTIVE_OS_REVERTTOSELF'),('PREEMPTIVE_OS_QUERYCONTEXTATTRIBUTES'),
		('PREEMPTIVE_OS_REPORTEVENT'),('PREEMPTIVE_OS_LOOKUPACCOUNTSID'),('PREEMPTIVE_OS_DELETESECURITYCONTEXT'),('PREEMPTIVE_OS_QUERYREGISTRY'),
		('PREEMPTIVE_OS_DISCONNECTNAMEDPIPE')
    ) AS E(wait_type)
)
SELECT TOP 15
   SUBSTRING(ws.wait_type,1,40) AS Wait_Type,
    STR(ws.wait_time_ms / 1000.0, 8, 2) AS wait_sec,
    STR(ws.signal_wait_time_ms / 1000.0, 8, 2) AS signal_wait_sec,
    ISNULL(wi.Category, 'Other') AS Category,
    ISNULL(wi.Description, 'Investigate: No specific description available.') AS Description,
    ISNULL(wi.Impact, 'Impact unknown; review workload.') AS Impact
FROM sys.dm_os_wait_stats AS ws
LEFT JOIN WaitInfo AS wi ON ws.wait_type = wi.wait_type
WHERE ws.wait_type NOT IN (SELECT wait_type FROM ExcludedWaits)
ORDER BY ws.wait_time_ms DESC;
PRINT '   '
PRINT N'‚ö†Ô∏è Only waits that may indicate performance issues are shown above. Review Category and Impact for troubleshooting guidance.';
PRINT '   '
    GOTO AfterItem;

--------------------------------------------------
Item16:

--16. Check tempdb current useage
SET NOCOUNT ON;
SET ANSI_WARNINGS OFF;  -- Suppress NULL aggregate warning

DECLARE @PagesUsed BIGINT;

SELECT @PagesUsed = ISNULL(SUM(user_object_reserved_page_count), 0)
FROM sys.dm_db_file_space_usage;

IF @PagesUsed > 0
BEGIN
    PRINT '   '
    PRINT '[16.---TempDB User Object Usage---]';
	PRINT '-----------------------------------'

    SELECT 
        ISNULL(SUM(user_object_reserved_page_count), 0) AS [UserObjectPagesUsed],
        (ISNULL(SUM(user_object_reserved_page_count), 0) * 1.0 / 128) AS [UserObjectSpaceMB]
    FROM sys.dm_db_file_space_usage;
END
ELSE
BEGIN 
  PRINT '[16--- Tempdb Usage ---]   '
  PRINT N'‚ö†Ô∏èTEMPDB IS NOT CURRENTLY IN USE!'
END
SET ANSI_WARNINGS ON;   -- Restore default behaviour
    GOTO AfterItem;

----------------------------------------------
Item17:

  --17.Top 10 CPU Consumers (Text-view aligned, with totals)
SET NOCOUNT ON;
PRINT '   '
PRINT '[17.---Top 10 CPU Consumers---]';
PRINT '-------------------------------'

-- Fixed widths:
-- RowNo(5) | CPU_ms(12) | CPU_HHMMSS(12) | ExecCnt(9) | AvgCPU_ms(12) | %Inst(7) | QueryText(200)
DECLARE @Header NVARCHAR(400) =
    'RowNo CPU_ms      CPU_HHMMSS   ExecCnt   AvgCPU_ms   %Inst  QueryText';
DECLARE @Separator NVARCHAR(400) =
      REPLICATE('-',5)  + ' '
    + REPLICATE('-',12) + ' '
    + REPLICATE('-',12) + ' '
    + REPLICATE('-',9)  + ' '
    + REPLICATE('-',12) + ' '
    + REPLICATE('-',7)  + ' '
    + REPLICATE('-',200);

PRINT @Header;
PRINT @Separator;

;WITH Base AS (
    SELECT
        qs.total_worker_time            AS total_worker_us,         -- microseconds
        qs.execution_count              AS ExecCnt,
        t.[text]                        AS QueryText
    FROM sys.dm_exec_query_stats AS qs
    CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS t
),
Totals AS (
    SELECT 
        SUM(CAST(total_worker_us AS BIGINT)) / 1000 AS InstTotalCPU_ms  -- instance total in ms
    FROM Base
),
TopCpu AS (
    SELECT TOP 10
        ROW_NUMBER() OVER (ORDER BY b.total_worker_us DESC)         AS RowNo,
        CAST(b.total_worker_us / 1000 AS BIGINT)                    AS CPU_ms,
        b.ExecCnt,
        CASE WHEN b.ExecCnt > 0 
             THEN CAST((b.total_worker_us / 1000.0) / b.ExecCnt AS DECIMAL(20,2))
             ELSE CAST(0.0 AS DECIMAL(20,2))
        END                                                         AS AvgCPU_ms,
        b.QueryText
    FROM Base b
    ORDER BY b.total_worker_us DESC
),
WithPct AS (
    SELECT
        tc.*,
        CAST(
            CASE WHEN t.InstTotalCPU_ms > 0 
                 THEN (tc.CPU_ms * 100.0) / t.InstTotalCPU_ms 
                 ELSE 0.0 
            END AS DECIMAL(6,2)
        ) AS PctOfInstance
    FROM TopCpu tc
    CROSS JOIN Totals t
),
-- Helper to render HH:MM:SS from milliseconds (no DATEADD to avoid overflow)
Render AS (
    SELECT
        RowNo,
        CPU_ms,
        ExecCnt,
        AvgCPU_ms,
        PctOfInstance,
        QueryText,
        -- Convert ms -> seconds
        CAST(CPU_ms / 1000 AS BIGINT) AS TotalSeconds
    FROM WithPct
)
SELECT
    CONCAT(
        RIGHT(SPACE(5)  + CAST(RowNo AS VARCHAR(5)), 5), ' ',
        RIGHT(SPACE(12) + CAST(CPU_ms AS VARCHAR(12)), 12), ' ',
        -- HH:MM:SS (hours may exceed 99 on very busy systems; we cap width, not value)
        RIGHT(
            SPACE(12) + 
            CONCAT(
                -- Hours can exceed 24; show total hours
                CAST((TotalSeconds / 3600) AS VARCHAR(12)), ':',
                RIGHT('0' + CAST(((TotalSeconds % 3600) / 60) AS VARCHAR(2)), 2), ':',
                RIGHT('0' + CAST((TotalSeconds % 60) AS VARCHAR(2)), 2)
            )
        , 12), ' ',
        RIGHT(SPACE(9)  + CAST(ExecCnt AS VARCHAR(9)), 9), ' ',
        RIGHT(SPACE(12) + CAST(AvgCPU_ms AS VARCHAR(12)), 12), ' ',
        RIGHT(SPACE(7)  + CAST(PctOfInstance AS VARCHAR(7)), 7), ' ',
        LEFT(
            REPLACE(REPLACE(QueryText, CHAR(13)+CHAR(10), ' '), CHAR(9), ' ')
        , 80)
    ) AS [RowNo CPU_ms CPU_HHMMSS ExecCnt AvgCPU_ms %Inst QueryText]
FROM Render
ORDER BY RowNo;

-- Footer: totals for Top 10 and percent of instance
;WITH Base AS (
    SELECT
        qs.total_worker_time AS total_worker_us
    FROM sys.dm_exec_query_stats AS qs
),
Totals AS (
    SELECT SUM(CAST(total_worker_us AS BIGINT)) / 1000 AS InstTotalCPU_ms
    FROM Base
),
Top10 AS (
    SELECT TOP 10
        CAST(qs.total_worker_time / 1000 AS BIGINT) AS CPU_ms
    FROM sys.dm_exec_query_stats qs
    ORDER BY qs.total_worker_time DESC
),
Agg AS (
    SELECT 
        (SELECT SUM(CPU_ms) FROM Top10) AS Top10CPU_ms,
        t.InstTotalCPU_ms
    FROM Totals t
)
SELECT
    -- Print a clean footer line with totals
    CONCAT(
        'Top10 Total CPU (ms): ',
        CAST(Top10CPU_ms AS VARCHAR(30)),
        ' | Top10 Total CPU (HH:MM:SS): ',
        CONCAT(
            CAST((Top10CPU_ms/1000)/3600 AS VARCHAR(20)), ':',
            RIGHT('0' + CAST((((Top10CPU_ms/1000)%3600)/60) AS VARCHAR(2)), 2), ':',
            RIGHT('0' + CAST(((Top10CPU_ms/1000)%60) AS VARCHAR(2)), 2)
        ),
        ' | % of Instance CPU: ',
        CAST(CASE WHEN InstTotalCPU_ms>0 THEN (Top10CPU_ms*100.0)/InstTotalCPU_ms ELSE 0.0 END AS DECIMAL(6,2)),
        '%'
    ) AS [Summary]
FROM Agg;

    GOTO AfterItem;

-------------------------------------------------
Item18:

 --18. Index and Stats
PRINT '[18.--- Index and Statistics ---]';
PRINT '--------------------------------';

SET NOCOUNT ON;

IF OBJECT_ID('tempdb..#IndexStats') IS NOT NULL DROP TABLE #IndexStats;
CREATE TABLE #IndexStats (
    DbName               sysname        NULL,
    SchemaName           sysname        NULL,
    BaseObjectName       sysname        NULL,
    FullObjectName       AS (QUOTENAME(SchemaName) + '.' + QUOTENAME(BaseObjectName)) PERSISTED,
    IndexName            NVARCHAR(200)  NULL,
    IndexType            NVARCHAR(60)   NULL,
    IsDisabled           bit            NULL,
    IsHypothetical       bit            NULL,
    LastIndexStatsUpdate datetime       NULL
);

DECLARE @sql NVARCHAR(MAX) = N'';

-- Build dynamic SQL for all online, writable user databases
SELECT @sql = (
    SELECT '
USE ' + QUOTENAME(name) + ';
INSERT INTO #IndexStats (DbName, SchemaName, BaseObjectName, IndexName, IndexType, IsDisabled, IsHypothetical, LastIndexStatsUpdate)
SELECT
    DB_NAME() AS DbName,
    OBJECT_SCHEMA_NAME(i.object_id) AS SchemaName,
    OBJECT_NAME(i.object_id) AS BaseObjectName,
    CASE 
        WHEN i.index_id = 0 THEN ''(HEAP)''
        ELSE ISNULL(i.name, ''(Unnamed)'')
    END AS IndexName,
    CASE i.type
        WHEN 0 THEN ''HEAP''
        WHEN 1 THEN ''CLUSTERED''
        WHEN 2 THEN ''NONCLUSTERED''
        WHEN 3 THEN ''XML''
        WHEN 4 THEN ''SPATIAL''
        WHEN 5 THEN ''CLUSTERED COLUMNSTORE''
        WHEN 6 THEN ''NONCLUSTERED COLUMNSTORE''
        WHEN 7 THEN ''NONCLUSTERED HASH''
        ELSE ''OTHER''
    END AS IndexType,
    i.is_disabled,
    i.is_hypothetical,
    STATS_DATE(i.object_id, i.index_id) AS LastIndexStatsUpdate
FROM sys.indexes AS i
WHERE i.object_id > 0
  AND OBJECTPROPERTY(i.object_id, ''IsMsShipped'') = 0
  AND i.index_id >= 0;
'
    FROM sys.databases
    WHERE database_id > 4       -- user DBs only
      AND state = 0             -- online
      AND is_read_only = 0      -- writable
    FOR XML PATH(''), TYPE
).value('.', 'NVARCHAR(MAX)');

-- Execute the dynamic SQL
EXEC sp_executesql @sql;

-- Instance-wide max last index stats update
PRINT '[Last Index Maintenance]';
SELECT MAX(LastIndexStatsUpdate) AS InstanceLastIndexMaintenance
FROM #IndexStats;

------------------------
-- Per-database summary
SELECT 
    DbName AS DatabaseName,
    MAX(LastIndexStatsUpdate) AS DbLastIndexStatsUpdate,
    SUM(CASE WHEN LastIndexStatsUpdate IS NOT NULL 
             AND LastIndexStatsUpdate >= DATEADD(day, -1, SYSDATETIME()) 
        THEN 1 ELSE 0 END) AS UpdatedLast24h,
    COUNT(*) AS TotalIndexes
FROM #IndexStats
GROUP BY DbName
ORDER BY DbName;

-- Top 100 oldest index maintenance
PRINT 'Oldest Index Maintenance';
PRINT '------------------------';

SELECT TOP 100
    DbName AS DatabaseName,
    FullObjectName,
    ISNULL(IndexName, '(HEAP)') AS IndexName,
    LastIndexStatsUpdate
FROM #IndexStats
WHERE LastIndexStatsUpdate IS NOT NULL
ORDER BY LastIndexStatsUpdate ASC;

DROP TABLE #IndexStats;
GOTO AfterItem;
   
-----------------------------------------------
Item19:

  --19. Query Store Results

PRINT '[19.--- Query Store Status ---]';
PRINT '-------------------------------'
PRINT '';
SET NOCOUNT ON;

DECLARE @LookbackDays INT = 7;       -- Lookback window in days
DECLARE @TopN INT = 10;              -- Top N queries per metric per database
DECLARE @MinExecutions BIGINT = 5;   -- Minimum executions to include

/********************************************************************
A) Query Store status across databases
*********************************************************************/
IF OBJECT_ID('tempdb..#DbStatus') IS NOT NULL DROP TABLE #DbStatus;
CREATE TABLE #DbStatus (
    DatabaseId INT,
    DatabaseName SYSNAME,
    CompatibilityLevel INT,
    IsQueryStoreAvailable BIT,
    ActualStateDesc NVARCHAR(60) NULL,
    DesiredStateDesc NVARCHAR(60) NULL,
    IsQueryStoreEnabled BIT,
    IsReadOnly BIT
);

DECLARE @db SYSNAME, @dbid INT, @compat INT, @readonly BIT, @cmd NVARCHAR(MAX);

DECLARE dbs CURSOR LOCAL FAST_FORWARD FOR
SELECT name, database_id, compatibility_level, is_read_only
FROM sys.databases
WHERE database_id > 4      -- exclude master, tempdb, model, msdb
  AND state = 0;           -- ONLINE

OPEN dbs;
FETCH NEXT FROM dbs INTO @db, @dbid, @compat, @readonly;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @cmd = N'
BEGIN TRY
    USE ' + QUOTENAME(@db) + N';
    INSERT INTO #DbStatus (DatabaseId, DatabaseName, CompatibilityLevel, IsQueryStoreAvailable, ActualStateDesc, DesiredStateDesc, IsQueryStoreEnabled, IsReadOnly)
    SELECT
        ' + CAST(@dbid AS NVARCHAR(10)) + N',
        ' + QUOTENAME(@db,'''') + N',
        ' + CAST(@compat AS NVARCHAR(10)) + N',
        1,
        qso.actual_state_desc,
        qso.desired_state_desc,
        CASE WHEN qso.actual_state_desc IN (''READ_WRITE'',''READ_ONLY'') THEN 1 ELSE 0 END,
        ' + CAST(@readonly AS NVARCHAR(1)) + N'
    FROM sys.database_query_store_options AS qso;
END TRY
BEGIN CATCH
    INSERT INTO #DbStatus (DatabaseId, DatabaseName, CompatibilityLevel, IsQueryStoreAvailable, ActualStateDesc, DesiredStateDesc, IsQueryStoreEnabled, IsReadOnly)
    SELECT
        ' + CAST(@dbid AS NVARCHAR(10)) + N',
        ' + QUOTENAME(@db,'''') + N',
        ' + CAST(@compat AS NVARCHAR(10)) + N',
        0, NULL, NULL, 0, ' + CAST(@readonly AS NVARCHAR(1)) + N';
END CATCH;
';
    EXEC sys.sp_executesql @cmd;
    FETCH NEXT FROM dbs INTO @db, @dbid, @compat, @readonly;
END

CLOSE dbs;
DEALLOCATE dbs;

SELECT
    SUBSTRING(DatabaseName,1,40) AS DatabaseName,
    CompatibilityLevel,
    IsQueryStoreAvailable,
    SUBSTRING(ActualStateDesc,1,20) AS ActualStateDesc,
    SUBSTRING (DesiredStateDesc,1,20) AS DesiredStaeDesc,
    IsQueryStoreEnabled,
    IsReadOnly,
    StatusHighlight = CASE
        WHEN IsQueryStoreAvailable = 0 THEN N'‚ö†Ô∏è Query Store not supported or inaccessible'
        WHEN IsQueryStoreEnabled = 0 THEN N'‚ö†Ô∏è Query Store NOT enabled'
        WHEN ActualStateDesc = 'READ_ONLY' THEN 'Query Store read-only (capture stopped)'
        ELSE N'‚úÖ Query Store enabled'
    END
FROM #DbStatus
ORDER BY IsQueryStoreEnabled DESC, DatabaseName;


/********************************************************************
B) Worst queries from Query Store (last @LookbackDays days)
   - No reliance on sys.plan_attributes
*********************************************************************/
IF OBJECT_ID('tempdb..#WorstQueriesRaw') IS NOT NULL DROP TABLE #WorstQueriesRaw;
CREATE TABLE #WorstQueriesRaw (
    DatabaseName SYSNAME,
    QueryId BIGINT,
    PlanId BIGINT,
    QueryText NVARCHAR(MAX),
    ObjectName SYSNAME NULL,
    AvgDurationMs DECIMAL(18,2),
    AvgCPUms DECIMAL(18,2),
    AvgLogicalReads DECIMAL(18,2),
    ExecutionCount BIGINT,
    LastExecutionTime DATETIME2(3),
    MetricCategory VARCHAR(20)
);

DECLARE @StartTime DATETIME2(0) = DATEADD(DAY, -@LookbackDays, SYSUTCDATETIME());

DECLARE enabled CURSOR LOCAL FAST_FORWARD FOR
SELECT DatabaseName
FROM #DbStatus
WHERE IsQueryStoreAvailable = 1
  AND IsQueryStoreEnabled = 1;

OPEN enabled;
FETCH NEXT FROM enabled INTO @db;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @cmd = N'
BEGIN TRY
    USE ' + QUOTENAME(@db) + N';

    IF NOT EXISTS (
        SELECT 1
        FROM sys.database_query_store_options
        WHERE actual_state_desc IN (''READ_WRITE'', ''READ_ONLY'')
    )
        RETURN;

    ;WITH qs AS (
        SELECT
            q.query_id,
            p.plan_id,
            qt.query_sql_text,
            rs.count_executions AS exec_count,
            rs.avg_duration * 1000.0 AS avg_duration_ms,
            rs.avg_cpu_time * 1000.0 AS avg_cpu_ms,
            rs.avg_logical_io_reads AS avg_logical_reads,
            rs.last_execution_time
        FROM sys.query_store_query AS q
        JOIN sys.query_store_plan AS p ON p.query_id = q.query_id
        JOIN sys.query_store_query_text AS qt ON qt.query_text_id = q.query_text_id
        JOIN sys.query_store_runtime_stats AS rs ON rs.plan_id = p.plan_id
        JOIN sys.query_store_runtime_stats_interval AS rsi ON rsi.runtime_stats_interval_id = rs.runtime_stats_interval_id
        WHERE rsi.end_time >= @StartTime
          AND rs.count_executions >= @MinExecutions
    ),
    top_duration AS (
        SELECT TOP (@TopN) *
        FROM qs
        ORDER BY avg_duration_ms DESC
    ),
    top_cpu AS (
        SELECT TOP (@TopN) *
        FROM qs
        ORDER BY avg_cpu_ms DESC
    ),
    top_reads AS (
        SELECT TOP (@TopN) *
        FROM qs
        ORDER BY avg_logical_reads DESC
    )
    INSERT INTO #WorstQueriesRaw (DatabaseName, QueryId, PlanId, QueryText, ObjectName, AvgDurationMs, AvgCPUms, AvgLogicalReads, ExecutionCount, LastExecutionTime, MetricCategory)
    SELECT DB_NAME(), query_id, plan_id, query_sql_text, NULL, avg_duration_ms, avg_cpu_ms, avg_logical_reads, exec_count, last_execution_time, ''Duration'' FROM top_duration
    UNION ALL
    SELECT DB_NAME(), query_id, plan_id, query_sql_text, NULL, avg_duration_ms, avg_cpu_ms, avg_logical_reads, exec_count, last_execution_time, ''CPU'' FROM top_cpu
    UNION ALL
    SELECT DB_NAME(), query_id, plan_id, query_sql_text, NULL, avg_duration_ms, avg_cpu_ms, avg_logical_reads, exec_count, last_execution_time, ''Reads'' FROM top_reads;
END TRY
BEGIN CATCH
    RETURN;
END CATCH;
';
    EXEC sp_executesql
        @cmd,
        N'@StartTime DATETIME2(0), @TopN INT, @MinExecutions BIGINT',
        @StartTime=@StartTime, @TopN=@TopN, @MinExecutions=@MinExecutions;

    FETCH NEXT FROM enabled INTO @db;
END

CLOSE enabled;
DEALLOCATE enabled;

-- Deduplicate and store in #WorstQueries (no ORDER BY in SELECT INTO)
IF OBJECT_ID('tempdb..#WorstQueries') IS NOT NULL DROP TABLE #WorstQueries;

SELECT
    DatabaseName,
    QueryId,
    PlanId,
    QueryText,
    ObjectName,
    AvgDurationMs,
    AvgCPUms,
    AvgLogicalReads,
    ExecutionCount,
    LastExecutionTime,
    MetricCategory
INTO #WorstQueries
FROM (
    SELECT *,
           ROW_NUMBER() OVER (
                PARTITION BY DatabaseName, QueryId, PlanId
                ORDER BY 
                    CASE MetricCategory
                        WHEN 'Duration' THEN AvgDurationMs
                        WHEN 'CPU'     THEN AvgCPUms
                        WHEN 'Reads'   THEN AvgLogicalReads
                    END DESC
           ) AS rn
    FROM #WorstQueriesRaw
) AS x
WHERE rn = 1;

PRINT '[--- Worst Queries from Query Store ---]';
PRINT  '---------------------------------------';
PRINT '';
SELECT
    SUBSTRING(DatabaseName,1,40)AS DatabasName,
    MetricCategory,
    QueryId,
    PlanId,
    AvgDurationMs,
    AvgCPUms,
    AvgLogicalReads,
    ExecutionCount,
    LastExecutionTime,
    QueryText = CASE 
        WHEN LEN(QueryText) > 4000 THEN LEFT(QueryText, 4000) + N' ‚Ä¶(truncated)'
        ELSE QueryText
    END
FROM #WorstQueries
ORDER BY DatabaseName,
         MetricCategory,
         CASE MetricCategory
            WHEN 'Duration' THEN AvgDurationMs
            WHEN 'CPU'      THEN AvgCPUms
            WHEN 'Reads'    THEN AvgLogicalReads
         END DESC;
-----------------------------------------------

    GOTO AfterItem;

-------------------------------------------------------
Item20:

PRINT  '[20. --- DDL Change Detection (Last 7 Days)---]'
PRINT  '----------------------------------------------';
DECLARE @ddl_count INT;

-- Count DDL events in the last 7 days
SELECT @ddl_count = COUNT(*)
FROM fn_trace_gettable(CONVERT(VARCHAR(255), 
    (SELECT TOP 1 value 
     FROM sys.fn_trace_getinfo(NULL) 
     WHERE property = 2)), DEFAULT) T
     WHERE T.EventClass IN (46,47,164) -- Object:Created,Deleted,Altered
  AND T.StartTime >= DATEADD(DAY, -7, GETDATE());

-- Conditional output
IF @ddl_count > 0
BEGIN
    PRINT N'‚ö†Ô∏è Recent DDL Changes (Last 7 Days)';
    SELECT 
        SUBSTRING(TE.name,1,30) AS EventName,
        SUBSTRING(T.DatabaseName,1,30) AS DatabaseName,
        SUBSTRING(T.ObjectName,1,30) AS ObjectName,
        T.ObjectType,
        T.TextData,
        SUBSTRING(T.LoginName,1,40) AS LoginName,
        SUBSTRING(T.HostName,1,40) AS HostName,
        SUBSTRING(T.ApplicationName,1,40) AS ApplicationName,
        T.StartTime
    FROM fn_trace_gettable(CONVERT(VARCHAR(255), 
        (SELECT TOP 1 value 
         FROM sys.fn_trace_getinfo(NULL) 
         WHERE property = 2)), DEFAULT) T
    JOIN sys.trace_events TE ON T.EventClass = TE.trace_event_id
    WHERE T.EventClass IN (46,47,164)
	  AND T.DatabaseName <> 'Tempdb'
      AND T.StartTime >= DATEADD(DAY, -7, GETDATE())
    ORDER BY T.StartTime DESC;
END
ELSE
BEGIN
    PRINT N'‚úÖ No DDL Changes found in the last 7 Days';
END

-- 2. Recently Modified Objects

IF EXISTS (
    SELECT 1 
    FROM sys.objects 
    WHERE modify_date >= DATEADD(DAY, -7, GETDATE())
)
BEGIN
    SELECT 
        SUBSTRING(name, 1, 30) AS ObjectName,
        SUBSTRING(type_desc, 1, 30) AS ObjDescription,
        create_date,
        modify_date
    FROM sys.objects
    WHERE modify_date >= DATEADD(DAY, -7, GETDATE())
    ORDER BY modify_date DESC;
END
ELSE
BEGIN
    PRINT N'‚úÖ No recent object modifications found in the last 7 days';
END

-- 3. Recent Login Creations or Changes

IF EXISTS (
    SELECT 1
    FROM sys.server_principals
    WHERE create_date >= DATEADD(DAY, -7, GETDATE())
       OR modify_date >= DATEADD(DAY, -7, GETDATE())
)
BEGIN
PRINT N'‚ö†Ô∏è Recent login creations or modifications found in the last 7 days';
    SELECT 
        SUBSTRING(name, 1, 40) AS LoginName,
        SUBSTRING(type_desc, 1, 20) AS Type,
        create_date,
        modify_date
    FROM sys.server_principals
    WHERE create_date >= DATEADD(DAY, -7, GETDATE())
       OR modify_date >= DATEADD(DAY, -7, GETDATE())
    ORDER BY modify_date DESC;
END
ELSE
BEGIN
    PRINT N'‚úÖ No recent login creations or modifications found in the last 7 days';
END

GOTO AfterItem;

--------------------------
-- Return to driver to fetch next item
--------------------------
AfterItem:
    -- Remove the processed item so the next one can be fetched
    DELETE FROM #Sel WHERE ItemID = @NextItem;
    SET @NextItem = NULL;
    GOTO GetNext;

EndScript:
  
    PRINT '';
	PRINT '[=== End of Diagnostics ===]';

